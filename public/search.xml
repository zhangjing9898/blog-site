<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[egret]]></title>
    <url>%2F2019%2F02%2F28%2Fegret%2F</url>
    <content type="text"><![CDATA[启动1234xxx(project name)egret create xxxegret build xxxegret startserver xxx -a draw1.draw 这里参数描述了当前画面渲染时候drawcall的次数2.cost 包含四个参数 enterframe阶段的开销引擎updateTransform开销引擎draw开销html5中canvas draw的开销3 fps 当前画面的帧屏 x y scalex和y alpha 透明度 rotation旋转 0x+颜色 bitmap 位图shape 矢量图textfieldtextinput 文本 遮罩 maskshape绘制图形xxx.mask 检测碰撞hitTestPoint(x, y, true)return booleantrue是看 与图形是否重合 锚点anchorOffsetX anchorOffsetY位置 添加与删除显示对象sprite 算是一个轻量级的显示对象 添加也就是 a.addChild(b)删除也就是 a.removeChild(b) 在删除的时候，需要注意一点，如果a不是this，而是一个容器或者其他的，那么我们需要先判断它是否存在，如果存在才能进行删除操作。123if(a.parent）&#123; a.removeChild(b)&#125; 深度管理深度管理就像是一个队列，但是更像是z-序列号这种东西。 Egret中容器的深度都是从0开始的，当一个显示对象第一个被添加到容器中时，它的深度值为0。这个显示对象也处于容器的最底层。当我们添加第二个显示对象的时候，他的深度值为1，并且在第一个显示对象上方。如果两个显示对象发生了相交，那么我们可以从视觉上看到，第二个显示对象遮挡住第一个显示对象。 深度插队当我们想讲某一个显示对象添加到一个指定深度的时候，我们需要使用 addChildAt 方法。这个操作很像排队时插队的想象。 使用 addChildAt 方法也非常的容易，具体使用方法如下： 容器.addChildAt( 显示对象, 深度值 ) 交换深度交换不同对象深度的功能Egret为开发者提供了两个方法。一个是 swapChildren 方法，另外一个是 swapChildrenAt 方法。 两个方法使用方式少有不同，但效果相同，具体使用方法如下： 容器.swapChildren( 显示对象, 显示对象 ) 容器.swapChildrenAt( 深度值, 深度值 ) 重设子对象深度当我们将一个显示对象添加到显示列表中后，我们还可以手动重设这个显示对象的深度。 实现显示对象深度重置的方法是 setChildIndex ，使用方法如下： 容器.setChildIndex( 显示对象, 新的深度值 ); 事件处理机制的原理event dispatcher 事件流程egret 事件机制包括4个步骤： 注册侦听器 发送事件 侦听事件 移除侦听器 按照上方面顺序依次执行 注册侦听器使用事件发送者的addEventListener()将相应的事件分配给侦听器 1public addEventListener(type:string, listener:Function, thisObject:any, useCapture:boolean = false, priority:number = 0) type：事件类型，必选。 listener：用来处理事件的侦听器，必选。 thisObject：作用域，必选，一般填写this。因为TypeScript与JavaScript的this作用域不同，其this指向也会不同。如果不填写this的话，那么编译后的代码会发生错误。 关于this的问题，可以学习JavaScript中的原型链。 useCapture: 确定侦听器是运行于捕获阶段还是运行于冒泡阶段，可选。设置为 true，则侦听器只在捕获阶段处理事件，而不在冒泡阶段处理事件。设置为 false，则侦听器只在冒泡阶段处理事件。 priority： 事件侦听器的优先级，可选。优先级由一个带符号的整数指定。数字越大，优先级越高。优先级为 n 的所有侦听器会在优先级为 n -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0 触摸事件Egret中有专门的触摸事件类，使用触摸事件时，默认需要打开显示对象的触摸开关，即将touchEnabled设置为true。]]></content>
      <categories>
        <category>egret</category>
        <category>游戏引擎</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络分层模型和TCP/IP协议族 ——IP协议]]></title>
    <url>%2F2019%2F02%2F11%2F%E7%BD%91%E7%BB%9C4%2F</url>
    <content type="text"><![CDATA[网络分层模型和TCP/IP协议族 ——IP协议这一篇文章主要记录IP协议相关内容。 IP协议是干什么的？寻址 + 路由选择 寻址中的址是什么？首先，它不是mac地址，而是ip地址，那么ip地址又是个什么东西呢？ 我在这里，举一个简单的例子：因为二进制数写起来和读起来都比较费劲，所以我们一般都换算为十进制。 其对应的子网掩码是这样的 11111111 11111111 11111111 00000000 转换为十进制，也就是：255 255 255 0 接着我们来依次对应下，这张图可以清楚的表示： 这里还提到了一个有意义的简写 如果子网掩码的前24位都是1的话，那么我们可以这样简写：/24 接下来补充一下，常见的ip地址列表。 ip地址列表 这里的127.0.0.1 环回也就是 本机地址。 寻址+路由ip协议中的路由分配以及寻址是怎么个过程呢？接下来慢慢分析。 同一个内网传递数据给出一个case： 同一个网段下，computerA想给computerB发送数据。 步骤： 首先，对应的是应用层 然后，把它扔进了TCP协议里，给它加上了端口，比如这里的80 再然后，扔进IP协议，包装上了ip地址 接着，扔进以太网，包装mac地址注意：在上一篇以太网中已经提到，如何通过ip地址找到**发送目标的**的mac地址，这里不再赘述 这样打包完成后，我们就可以顺畅的把数据发出去啦~ 网络间的数据传送说完了内网之间的数据传送，接下来我们说说非内网间，它是怎么进行数据传送的。 computerA（192.168.0.1）准备给不同网段的computerB（172.16.0.1）发送数据 步骤： 先发给网关，具体同上 然后发给路由器A 路由器上都有个路由表 查看是否直连 同上进行发送 IP分片和重组 路径发现MTU我觉得这个机制还是挺有意思，简单来说，我们在发送数据帧的时候，如果它的大小超过网络MTU，那么它会停止发送，并自动调整路径，再重新发送。这个还是挺智能的。 IP相关协议 其实常用的也就是dns，其他的做个了解就可以了。]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络分层模型和TCP/IP协议——以太网]]></title>
    <url>%2F2019%2F02%2F10%2F%E7%BD%91%E7%BB%9C3%2F</url>
    <content type="text"><![CDATA[网络分层模型和TCP/IP协议——以太网以太网其实讲的就是：怎么传IP协议讲的就是：解决往哪里传的问题UDP和TCP：解决可靠性的问题 怎么传输的？最初是通过同轴电缆。 然后发现了一种算法来解决这个问题。 CSMA/CD也就是载波监听多路访问/冲突检测 我用大白话来讲解一下，大概就是这样的： 一条同轴电缆上，串联着许多台计算机，如果说computerA想发送数据（data），那么它会这样做： 先检查一下这个网络有没有人在使用 如果有人使用，它就不传了，避免冲突 没人使用，那就可以传数据。 如果说，存在这么一个情况：2个计算器同时检测到网络没人使用，然后他们准备同时发数据，这个时候会出现什么事呢？ computer在发送数据前，它会检查电压，一旦电压超过指定值，它就会停止传输数据，通过物理知识我们可以知道，串联是电流处处相等，电压=各处相加。 一旦检测到电压超值，那么computer会stop send data，然后等待一段时间，再继续传值，这个等待的时间是随机产生的。 最后，梅特卡夫把这套系统名为以太网 以太网发展过程 网卡和mac地址 二层交换机交换机是根据mac地址来转发数据的 以太网数据帧格式 这里提到的FCS帧检验序列，也就是用于检验是否丢帧。]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络分层模型和TCP/IP协议——协议的斗争]]></title>
    <url>%2F2019%2F02%2F08%2F%E7%BD%91%E7%BB%9C2%2F</url>
    <content type="text"><![CDATA[网络分层模型和TCP/IP协议族（第二章）继续上一部分，讲讲网络协议的东西。 之前主要分为2 part，一边是osi，一边是tcp/ip。可以形象地称为 协议斗争。 什么是OSI？OSI就是有国际标准化组织ISO提出的Open System Interconnection Reference Model（开放式系统互联通信参考模型） 他们主要提出了layer 7. 媒介层主要是做比较基础的部分，主机层是基于媒介层做了一些上层建筑封装等…相对单一 物理层物理层 -&gt; （不一定可靠） 点对点的数据直链，传输的是bit比特。 数据链路层一个可靠的点对点数据直链。 检错和纠错（CRC码） 多路访问 寻址 传递的是frame 数据帧 网络层 在网络的各个节点之间进行地址分配、路由和（不一定可靠的）报文分发。 路由 拥塞控制 传递的是package 数据包 传输层被称为4层 / L4 在网络的各个节点之间可靠地分发数据包 所有传输遗留问题 复用 流量 可靠 传输的是segment 数据段 在传输层之上的有会话层和表示层，但是用的不太多应用层称为7层 / L7 网络进程到应用程序。针对特定应用，规定各层协议、时序、表示等，进行封装。在端系统中用软件来实现，比如http等。 TCP/IP 它是怎么工作的？ ARP也就是通过ip地址来反查以太网mac地址。 我们来看看它到底包装了哪些？ 我们再来看看OSI的渊源 为什么失败了？ 进程缓慢 过于复杂 收费 TCP/IP的渊源 最后还是TCP/IP赢了]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络分层模型和TCP/IP协议族——网络传输哪里难]]></title>
    <url>%2F2019%2F02%2F04%2F%E7%BD%91%E7%BB%9C1%2F</url>
    <content type="text"><![CDATA[网络分层模型和TCP/IP协议族（第一章）实习完回家后，准备来回顾一下网络基础的相关知识点。 网络传输先举一个简单易懂的例子。 网络传输，我们可以比喻为2个人：甲 和 乙。然后他们之间需要传递一张图片picture。因为现在的图片还是挺大的，差不多几M的样子，这时候，就像是把一栋house传送过去。 如何传送呢？ 需要知道目标地址 寻址和路由 需要有一条到目标地址的路 数据链路 需要把大楼拆成包装箱能放下的大小 分片 需要将每一个部分进行编号 序列码 需要将包装箱装车 封装 车队运输时可能会堵车 拥塞控制 检查每一车是否完整 错误检验和校正 处理在运输路上丢失和损毁的部分 数据重发 拆成包装，将每一部分重新组装起来 重组 协议接着上面说的，我们肯定需要一些 流程规范、运输指南的使用说明，比如： 如何查找目的地 如何选择运输路线 如何拆分和重建大楼 这些规范被称为协议 协议需要注意这些： 协议有很多种 不同的协议处理不同层次的问题 发送方和接收方要使用相同的协议，才能还原数据]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2018%2F12%2F07%2F2021-12-07-vuex%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[vuex简单介绍前面对vue的源码进行了简单的解析，接下来vuex的简单剖析一下，当我们开发的不是单页面的时候，或者说涉及的项目比较大的时候，通过简答的父子组件之间值的传递，这种办法不太科学。 所以需要一个多组件状态共享的东西，简单来说，这就是vuex的作用。 1. vuex是什么 GitHub站点 https://github.com/vuejs/vuex 在线文档: https://vuex.vuejs.org/zh-cn/ 简单来说，它是对应用中组件的状态进行了集中式的一个管理(读/写) 2. 状态自管理应用 state: 驱动应用的数据源 view: 以声明方式将state映射到视图 声明方式 -&gt; eg: actions: 响应在view上的用户输入导致的状态变化(包含n个更新状态的方法) action-&gt;函数 举一个例子🌰 点击一个button，状态改变到页面改变的过程： view -&gt; 点击 button -&gt; 需要actions中的方法 -&gt; 方法用于改变值 -&gt; 进入state状态管理 -&gt; 改变state中的状态 -&gt; 状态改变后，view更新 3. 多组件共享状态的problem 多个视图依赖同一个状态 来自不同的视图的行为 需要变更同一个状态 没有vuex的解决方法 将数据和操作数据的行为都定义在父组件 将数据和操作数据的行为传递给需要的各个子组件(有时候会多级传递) vuex的基础概念下面列举一些vuex的基础概念 state vuex管理的状态 它是一个对象 它是唯一的 例子🌰 123const state = &#123; a: initValue&#125; mutations 包含多个直接更新state的方法 它也是一个对象 谁来触发？ action中的commit(‘mutation名称’) 只能包含同步的代码，不能写异步 例子🌰 12345const mutations = &#123; xxx(state, data)&#123; // 更新state的某个属性 &#125;&#125; actions 包含多个事件回调函数 它也是一个对象 通过执行 commit()来触发mutation的调用 间接更新state 如何触发？ 组件中 store.dispatch(‘action名称) 可以异步执行(定时器，ajax) 例子🌰 1234567const actions = &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; getters 包含多个计算属性(get) 同理 也是一个对象 如何读取？ store.getters.doneTodosCount 例子🌰 12345const getters = &#123; doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125; modules 包含多个module 一个module是一个store的配置对象 向外暴露store对象123456export default new Vuex.store(&#123; state, mutations, getters, actions&#125;) 组件内12345import &#123;mapGetters, mapActions&#125; from 'vuex';export default &#123; computed: mapGetters(['aaa']); methods: mapActions(['bbb']);&#125; 映射store1234import store from './store';new Vue(&#123; store&#125;) store对象 所有用vuex管理的组件中都多了一个属性$store, 它就是一个store对象 属性: state: 注册的state对象 getters: 注册的getters对象 方法: dispatch(actionName, data): 分发调用action]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码解析(第六弹)]]></title>
    <url>%2F2018%2F12%2F06%2F2020-12-06-vue%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6(%E7%AC%AC%E5%85%AD%E5%BC%B9)%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[vue源码探究(第六弹)继续之前的，差不多到最后一part了，数据的双向绑定。 双向数据绑定 双向数据绑定是建立在单向数据绑定(model ==&gt; view)的基础之上的 双向数据绑定的实现流程 在解析v-model指令中，给当前元素添加input监听 当input的value发生变化时，将最新的值赋值给当前表达式所对应的data属性 举个例子🌰1234567891011121314151617181920212223&lt;div id="test"&gt; &lt;input type="text" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new MVVM(&#123; el: '#test', data: &#123; msg: 'haha' &#125; &#125;) // 通过v-model 我们可以实现数据的双向绑定 下面来简述一下流程 // 1. 进入 new MVVM() // 2. observe 对数据进行监视 // 3. new Observer(value) // 4. 对指定属性实现响应式的数据绑定 defineReactive // 5. new Dep -&gt; defineProperty 添加get和set fn // 6. 进入compile编译 // 7. step1 -&gt; node2Fragment 文档碎片 将node进行批量处理 // 8. step2 -&gt; init() -&gt; compileElement() -&gt; 元素ele node -&gt; compile() -&gt; attrName = v-module // 9. bind() -&gt; 先getVal() -&gt; modelUpdater 更新数据 // 10. new watcher() 用于监听属性值的变化 自动调用 更新对应的节点&lt;/script&gt; 最后附上一张图 Endvue的源码探究暂时就到这里了，bye🎓]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue源码解析(第五弹)]]></title>
    <url>%2F2018%2F12%2F05%2F2019-12-05-vue%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6(%E7%AC%AC%E4%BA%94%E5%BC%B9)%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[vue源码探究(第五弹)不知不觉，到了vue源码探究的最后一部分，也是最为复杂的一部分，数据劫持和数据的双向绑定。 数据劫持数据劫持我们也可以称为数据绑定。 初始化显示：页面(表达式/指令)能从data读取数据显示(编译/解析) 更新显示：更新data中的属性数据 ===》 页面更新 相关问题 prepare dep 与data中的属性一一对应 watcher 与模板中一般指令/大括号表达式一一对应 什么时候一个dep中关联多个watcher?多个指令或表达式用到了当前同一个属性 什么时候一个watcher中关联多个dep?多层表达式的watcher对应多个dep 例子🌰12345678910111213141516171819202122232425262728293031&lt;div id="test"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p v-text="name"&gt;&lt;/p&gt; &lt;p v-text="wife.name"&gt;&lt;/p&gt; &lt;button v-on:click="update"&gt;更新&lt;/button&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; new MVVM(&#123; el: '#test', data: &#123; name: 'sadamu', // dep0 wife: &#123; // dep1 name: 'binbin', // dep2 age: 18 // dep3 &#125; &#125;, methods: &#123; update () &#123; this.name = 'avatar' &#125; &#125; // 主要梳理一下，数据改变如何 -&gt; 页面变化 // 1. tap button -&gt; update Fn -&gt; this.name = 'xxx' // 2. 数据劫持中的set方法 // 3. newVal -&gt;是object,需要observe(类似a.b.c这种) —&gt; 不是对象,进入dep.notify // 4. notify -&gt; 通知all watcher -&gt; forEach -&gt; sub.update() // 5. watcher中的update 方法，进入 run() // 6. old 和 new value 进行比较，若不同，进入callback更新界面 // 7. callback是updateFn,同上 &#125;)&lt;/script&gt; Dep接下来讲讲什么是Dep？ Dep(Depend) data中的每个属性(所有层次)都对应一个dep对象 dep创建的时机？ 在初始化define data中，每个属性会创建对应的dep对象 在data中的某个属性值被设置为新的对象的时候 个数 与data中的属性一一对应 dep对象的结构{ id, // 每个dep都有一个唯一的id subs //包含n个对应watcher的数组(subscribes的简写) 它是一个array[]} subs属性说明 当一个watcher被创建时，内部会将当前watcher对象添加到对应的dep对象的subs中 当此data属性的值发生变化时，所有subs中的watcher都会收到更新的通知，从而更新对应的界面 Watcher继续讲讲watcher 个数 模板中每一个非事件指令或者表达式都对应一个watcher对象 事件指令，eg:v-on、v-bind… 监视当前表达式数据的变化 创建的时机 在初始化编译模板的时候 watch对象的组成{ vm, // vm对象 exp, // 对应指令的表达式 cb, // callback 当表达式所对应的数据发生变化时候的回调函数 value, //当前表达式的值 depIds // 表达式中各级属性所对应的dep对象的集合对象，它是一个对象object} 总结dep与watcher的关系是: n:n(多对多) 一个data中的属性对应一个dep，一个dep中可能包含多个watcher 举个例子🌰：模板中多个地方使用一个表达式或者说使用一个属性。 &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; 这个时候，一个dep对应多个watcher 模板中每一个非事件指令或表达式都对应一个watcher，一个watcher中可能包含多个dep 举个例子🌰：表达式中包含了几个data属性 &lt;div&gt;&lt;/div&gt; 这里的一个watcher，就对应了3个dep 数据绑定使用到的2个核心技术 defineProperty() 消息订阅与发布]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue源码解析(第四弹)]]></title>
    <url>%2F2018%2F11%2F26%2F2018-11-26-vue%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6(%E7%AC%AC%E5%9B%9B%E5%BC%B9)%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[vue源码探究（第四弹）结束了上一part的数据代理，这一部分主要讲讲vue的模板解析，感觉这个有点难理解，而且内容有点多，hhh。 模板解析废话不多说，先从简单的入手。 按照之前的套路，先举一个例子🌰： 12345678910111213141516&lt;div id="test"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type="text/javascript" src="js/mvvm/compile.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mvvm/mvvm.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mvvm/observer.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mvvm/watcher.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; new MVVM(&#123; el: '#test', data: &#123; name: '喵喵喵' &#125; &#125;) // 这时候，我们的页面还是渲染出 喵喵喵&lt;/script&gt; 接下来讲讲内部的相关实现： 我们的MVVM中的构造函数中有什么东西，可以解析我们的模板呢？ 12// 创建一个用来编译模板的compile对象this.$compile = new Compile(options.el || document.body, this) 什么是Compile？一行一行注释着解读 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233function Compile(el, vm) &#123; // 保存vm this.$vm = vm; // 保存el元素 this.$el = this.isElementNode(el) ? el : document.querySelector(el); // 如果el元素存在 if (this.$el) &#123; // 1. 取出el中所有子节点, 封装在一个framgment对象中 // 这里的node2Fragment 就是将node -&gt; 放入 Fragment中，documentFragment将node进行批量处理 this.$fragment = this.node2Fragment(this.$el); // 2. 编译fragment中所有层次子节点 this.init(); // 3. 将fragment添加到el中 this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; node2Fragment: function (el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;, init: function () &#123; // 编译fragment this.compileElement(this.$fragment); &#125;, compileElement: function (el) &#123; // 得到所有子节点 var childNodes = el.childNodes, // 保存compile对象 me = this; // 遍历所有子节点 [].slice.call(childNodes).forEach(function (node) &#123; // 得到节点的文本内容 var text = node.textContent; // 正则对象(匹配大括号表达式) var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // &#123;&#123;name&#125;&#125; // 这里提出一个问题，为什么这里的正则匹配要用/\&#123;\&#123;(.*)\&#125;\&#125;/，而不是/\&#123;\&#123;.*\&#125;\&#125;/呢？ // 其实/\&#123;\&#123;.*\&#125;\&#125;/就可以匹配到&#123;&#123;xxx&#125;&#125;,这里加一个()的意义是，用于.$1，来取得&#123;&#123;&#125;&#125;中的值，eg：name // 如果是元素节点 if (me.isElementNode(node)) &#123; // 编译元素节点的指令属性 me.compile(node); // 如果是一个大括号表达式格式的文本节点 &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; // 编译大括号表达式格式的文本节点 me.compileText(node, RegExp.$1); // RegExp.$1: 表达式 name &#125; // 如果子节点还有子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; // 递归调用实现所有层次节点的编译 me.compileElement(node); &#125; &#125;); &#125;, compile: function (node) &#123; // 得到所有标签属性节点 var nodeAttrs = node.attributes, me = this; // 遍历所有属性 [].slice.call(nodeAttrs).forEach(function (attr) &#123; // 得到属性名: v-on:click var attrName = attr.name; // 判断是否是指令属性 if (me.isDirective(attrName)) &#123; // 得到表达式(属性值): test var exp = attr.value; // 得到指令名: on:click var dir = attrName.substring(2); // 事件指令 if (me.isEventDirective(dir)) &#123; // 解析事件指令 compileUtil.eventHandler(node, me.$vm, exp, dir); // 普通指令 &#125; else &#123; // 解析普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; // 移除指令属性 node.removeAttribute(attrName); &#125; &#125;); &#125;, compileText: function (node, exp) &#123; // 调用编译工具对象解析 compileUtil.text(node, this.$vm, exp); &#125;, isDirective: function (attr) &#123; return attr.indexOf('v-') == 0; &#125;, isEventDirective: function (dir) &#123; return dir.indexOf('on') === 0; &#125;, isElementNode: function (node) &#123; return node.nodeType == 1; &#125;, isTextNode: function (node) &#123; return node.nodeType == 3; &#125;&#125;;// 指令处理集合var compileUtil = &#123; // 解析: v-text/&#123;&#123;&#125;&#125; text: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // 解析: v-html html: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'html'); &#125;, // 解析: v-model model: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'model'); var me = this, val = this._getVMVal(vm, exp); node.addEventListener('input', function (e) &#123; var newValue = e.target.value; if (val === newValue) &#123; return; &#125; me._setVMVal(vm, exp, newValue); val = newValue; &#125;); &#125;, // 解析: v-class class: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'class'); &#125;, // 真正用于解析指令的方法 bind: function (node, vm, exp, dir) &#123; /*实现初始化显示*/ // 根据指令名(text)得到对应的更新节点函数 // 取到一个object的属性，有2个方法，一个是obj. 一个是obj[] // 当我们要取得属性是一个变量的时候，使用obj[] var updaterFn = updater[dir + 'Updater']; // 如果存在调用来更新节点 updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)); // 创建表达式对应的watcher对象 new Watcher(vm, exp, function (value, oldValue) &#123;/*更新界面*/ // 当对应的属性值发生了变化时, 自动调用, 更新对应的节点 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;, // 事件处理 eventHandler: function (node, vm, exp, dir) &#123; // 得到事件名/类型: click var eventType = dir.split(':')[1], // 根据表达式得到事件处理函数(从methods中): test()&#123;&#125; fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; // 如果都存在 if (eventType &amp;&amp; fn) &#123; // 绑定指定事件名和回调函数的DOM事件监听, 将回调函数中的this强制绑定为vm node.addEventListener(eventType, fn.bind(vm), false); &#125; &#125;, // 得到表达式对应的value _getVMVal: function (vm, exp) &#123; // 这里为什么要forEach呢？ // 如果你的exp是a.b.c.c.d呢 就需要forEach 如果只是一层 当然不需要遍历啦 var val = vm._data; exp = exp.split('.'); exp.forEach(function (k) &#123; val = val[k]; &#125;); return val; &#125;, _setVMVal: function (vm, exp, value) &#123; var val = vm._data; exp = exp.split('.'); exp.forEach(function (k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; val = val[k]; &#125; else &#123; val[k] = value; &#125; &#125;); &#125;&#125;;// 包含多个用于更新节点方法的对象var updater = &#123; // 更新节点的textContent textUpdater: function (node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125;, // 更新节点的innerHTML htmlUpdater: function (node, value) &#123; node.innerHTML = typeof value == 'undefined' ? '' : value; &#125;, // 更新节点的className classUpdater: function (node, value, oldValue) &#123; var className = node.className; className = className.replace(oldValue, '').replace(/\s$/, ''); var space = className &amp;&amp; String(value) ? ' ' : ''; node.className = className + space + value; &#125;, // 更新节点的value modelUpdater: function (node, value, oldValue) &#123; node.value = typeof value == 'undefined' ? '' : value; &#125;&#125;; 最后未完待续…接下来，还有一个更有趣的东西 下一章继续~]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue源码解析(第三弹)]]></title>
    <url>%2F2018%2F11%2F25%2F2018-11-25-vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E7%AC%AC%E4%B8%89%E5%BC%B9)%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[vue源码探究（第三弹）结束了之前prepare，现在开始正式进入vue源码探究部分 数据代理先从简单的入手，我们先手动实现一个简易版的数据代理吧。 基础知识 vue数据代理: data对象的所有属性的操作(读/写)由vm对象来代理操作 好处: 通过vm对象就可以方便的操作data中的数据 实现:1). 通过Object.defineProperty(vm, key, {})给vm添加与data对象的属性对应的属性2). 所有添加的属性都包含get/set方法3). 在get/set方法中去操作data中对应的属性 举个例子🌰 12345678910111213141516171819&lt;div id="test"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="js/mvvm/compile.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mvvm/mvvm.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mvvm/observer.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/mvvm/watcher.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 这里取名为mvvm 是因为在mvvm.js中 // 是这样暴露的 function MVVM(options) &#123;&#125; 这里的MVVM和vue是一样的 只是一个命名的问题 const vm = new MVVM(&#123; el: "#test", data: &#123; name: '张三2' &#125; &#125;) console.log(vm.name) // 读取的是data中的name, vm代理对data的读操作 vm.name = '李四2' // 数据保存到data中的name上, vm代理对data的写操作 console.log(vm.name, vm._data.name) // 李四2 李四2&lt;/script&gt; 上面这部分是为了简单说明，我们写的mvvm实现了简单的数据代理，接下来，我们来剖析一下它的内部实现。先揭一个底，它的核心实现就是之前讲过的Object.defineProperty 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*相关于Vue的构造函数 */function MVVM(options) &#123; // 将选项对象保存到vm this.$options = options; // 将data对象保存到vm和datq变量中 var data = this._data = this.$options.data; //将vm保存在me变量中 var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function (key) &#123; // 属性名: name // 对指定属性实现代理 me._proxy(key); &#125;); // 对data进行监视 observe(data, this); // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function (key, cb, options) &#123; new Watcher(this, key, cb); &#125;, // 对指定属性实现代理 _proxy: function (key) &#123; // 保存vm var me = this; // 给vm添加指定属性名的属性(使用属性描述) Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = 'xxx'时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); &#125;&#125;; Tips：在源码学习的过程中，掌握到了一个小技巧，读源码的时候，debugger会更加的方便。 非常好用，我之前太蠢了，只会第一个resume script execution 最后未完待续…接下来，还有一个更有趣的东西 下一章继续~]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue源码解析(第二弹)]]></title>
    <url>%2F2018%2F11%2F24%2F2018-11-24-vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[vue 源码探究（第二弹）接着上一篇，继续来讲一个非常有意思的东西documentFragment 解析六、DocumentFragment: 文档碎片(高效批量更新多个节点)这里先甩出 2 个概念，什么是 document，以及什么是 documentFragment document: 对应显示的页面, 包含 n 个 element 一旦更新 document 内部的某个元素界面更新 documentFragment: 内存中保存 n 个 element 的容器对象(不与界面关联), 如果更新 framgnet 中的某个 element, 界面不变 如果说，我们想要批量更新多个节点，可不可以这样理解，放入 documentFragment 中去，更新完了之后，再插入 document 中，因为 documentFragment 也是 document 下的一个节点。 举一个简单的例子： 12345&lt;ul id="fragment_test"&gt; &lt;li&gt;test1&lt;/li&gt; &lt;li&gt;test2&lt;/li&gt; &lt;li&gt;test3&lt;/li&gt;&lt;/ul&gt; 如果我们想把ul中li中的文本信息，全部由testx变成zhangjing123，原始的方式是不是这样做： 遍历 更改 这样，是不是document刷新了3次，如果说有1万个li呢，document是不是要刷新1万次？明显这样很不好，那么文档碎片出场了。 1234567891011121314151617181920212223242526272829303132333435 const ul = document.getElementById('fragment_test') // 1. 创建fragment const fragment = document.createDocumentFragment() // 2. 取出ul中所有子节点取出保存到fragment // 这里提一个小问题，如果这样的代码，会变成啥样？ // let child // while(child=ul.firstChild) &#123; // &#125; // 答案：死循环 // 那为什么加了一行 fragment.appendChild(child) 就可以呢？ // 因为一个节点只能有一个父亲 // NOTICE：ul和li中的换行也是一个文本节点，所以我们使用// firstChild用法// 此属性能够获取指定元素节点下的第一个子节点。// 如果元素下没有子节点，那么返回null。// 特别说明：// （1）.子节点并不一定都是元素节点，还有可能包含文本节点或者注释节点等节点。// （2）.空格或者换行被看做文本节点。 let child while(child=ul.firstChild) &#123; // 一个节点只能有一个父亲 fragment.appendChild(child) // 先将child从ul中移除, 添加为fragment子节点 &#125; // 3. 更新fragment中所有li的文本 Array.prototype.slice.call(fragment.childNodes).forEach(node =&gt; &#123; if (node.nodeType===1) &#123; // 元素节点 &lt;li&gt; node.textContent = 'zhangjing123' &#125; &#125;) // 4. 将fragment插入ul ul.appendChild(fragment) 未完待续…接下来，还有一个更有趣的东西 下一章继续~]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue源码解析(第一弹)]]></title>
    <url>%2F2018%2F11%2F23%2Fvue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E7%AC%AC%E4%B8%80%E5%BC%B9)%2F</url>
    <content type="text"><![CDATA[vue 源码探究（第一弹）最近在深 vue，接下来会有记录一系列 vue 源码解析方面的东西，主要从 3 个方面，开始解读： 数据代理 模板解析 数据双向绑定 在解析这些的时候，会发现源码中用到了很多 js 中比较核心但平时用的比较少的东西，在这里也先做一个 prepare 的预热吧。 问题 [].slice.call(lis): 将伪数组转换为真数组 node.nodeType: 得到节点类型 Object.defineProperty(obj, propertyName, {}): 给对象添加属性(指定描述符) Object.keys(obj): 得到对象自身可枚举属性组成的数组 obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性 DocumentFragment: 文档碎片(高效批量更新多个节点) 解析一、如何将伪数组转换为真数组首先抛出一个问题，什么叫做伪数组？ 12const lis = document.getElementsByTagName('li') // lis是伪数组(是一个特别的对象, length和数值下标属性)console.log(lis instanceof Object, lis instanceof Array, lis.forEach)// 打印结果 true false undefined 在 ES6 中，我们可以通过这样一个方法，把伪数组转为真数组 1Array.from(lis); //es6中将伪数组-&gt;真数组 如果说，在 ES5 中，我们应该怎么做呢？ 123const lis2 = Array.prototype.slice.call(lis); // lis.slice() 通过lis调用sliceconsole.log(lis2 instanceof Object, lis2 instanceof Array, lis2.forEach);// true true ƒ forEach() &#123; [native code] &#125; 这里再顺便拓展一下 slice 吧 1234567891011// 数组的slice()截取数组中指定部分的元素, 生成一个新的数组 [1, 3, 5, 7, 9], slice(0, 3)// slice2() 内部实现Array.prototype.slice2 = function (start, end) &#123; start = start || 0 end = start || this.length const arr = [] for (var i = start; i &lt; end; i++) &#123; arr.push(this[i]) &#125; return arr&#125; 二、node.nodeType: 得到节点类型先 show code： 1234567const elementNode = document.getElementById('test');const attrNode = elementNode.getAttributeNode('id');const textNode = elementNode.firstChild;console.log(elementNode, attrNode, textNode);// &lt;div id="test"&gt;教育&lt;/div&gt; id="test" "教育"console.log(elementNode.nodeType, attrNode.nodeType, textNode.nodeType);// 1 2 3 三、Object.defineProperty(obj, propertyName, {}): 给对象添加属性(指定描述符)vue 源码中用到了很多次这个属性，数据的双向绑定底层实现也是运用到它，还是很有意思，hhh 简单举一个例，让它做到数据绑定。 1234567891011121314151617181920212223242526272829const obj = &#123; firstName: 'A', lastName: 'B'&#125;// 如果说，我们想得到这个：obj.fullName = 'A-B'// 参数介绍：// obj 要在其上定义属性的对象。// prop 要定义或修改的属性的名称。// descriptor 将被定义或修改的属性描述符Object.defineProperty(obj, 'fullName', &#123; // 属性描述符: // 数据描述符 // 访问描述符 // 当读取对象此属性值时自动调用, 将函数返回的值作为属性值, this为obj get () &#123; return this.firstName + "-" + this.lastName &#125;, // 当修改了对象的当前属性值时自动调用, 监视当前属性值的变化, 修改相关的属性, this为obj set (value) &#123; const names = value.split('-') this.firstName = names[0] this.lastName = names[1] &#125;&#125;)console.log(obj.fullName) // A-Bobj.fullName = 'C-D'console.log(obj.firstName, obj.lastName) // C D// 是不是感觉很像v-module中的双向数据绑定 看了简单的绑定，我们再来深入一下~紧接着上面的 123456789101112131415161718192021Object.defineProperty(obj, 'fullName2', &#123; configurable: false, //是否可以重新define enumerable: true, // 是否可以枚举(for..in / keys()) 这个在下面的object.key() 中会 深受感触 value: 'A-B', // 指定初始值 writable: false // value是否可以修改&#125;)console.log(obj.fullName2) // A-Bobj.fullName2 = 'E-F'console.log(obj.fullName2) // A-B// 为什么会出现这个问题呢？是不是因为writable的原因？那我们可以改一下吗？Object.defineProperty(obj, 'fullName2', &#123; configurable: true, enumerable: true, value: 'G-H', writable: true&#125;)// 这时候会报错// Uncaught TypeError: Cannot redefine property:fullName2//at Function.defineProperty (&lt;anonymous&gt;)// 相信你已经懂了吧 讲到这里，会提到一个题外话，为什么说 vue 不支持 ie8 呢？因为 Object.defineProperty 是 es5 中新增的东西，它不支持 ie8，而 vue 中的数据绑定等多处用到该属性，所以，这也就是为什么 vue 不支持 ie8，因为这个方法不支持 ie8 四、Object.keys(obj): 得到对象自身可枚举属性组成的数组这里敲黑板、划重点 对象自身 可枚举 1234const names = Object.keys(obj);console.log(names);// ["firstName", "lastName", "fullName2"]// 为什么没有 fullName 因为fullname中的enumerable不是true 默认为false。 五、obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性这个属性还是有很多地方会用到。具体是干嘛的？相信直译就可以了解，看这个属性是不是自身的。因为有些属性虽然可以用，但有可能是原型链上的，而不是自己的，这个方法可以用于检测 12console.log(obj.hasOwnProperty('fullName'), obj.hasOwnProperty('toString'));// true false 未完待续…接下来，还有一个更有趣的东西，文档碎片(高效批量更新多个节点)，这也是为什么vue可以批量更新节点。 下一章继续~]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发tips]]></title>
    <url>%2F2018%2F11%2F22%2F2018-11-22-%E5%BC%80%E5%8F%91tips%2F</url>
    <content type="text"><![CDATA[解决公众号关注需要在指定域名下的问题 打开支付宝应用助手 设置 - 支付宝 - 应用中心设置 - 应用助手打开 打开支付宝中的“应用” 然后把图中的这个开关打开，即可。 如何快速找到线上页面对应的js资源很多时候，有断点需求，这时候快速找到线上页面对应的js资源就显得尤为重要。 step1：点击sources step2：有没有觉得这些很眼熟 step3：]]></content>
      <categories>
        <category>开发tips</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue自定义插件]]></title>
    <url>%2F2018%2F11%2F18%2F2018-11-18-vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue自定义插件废话不说多，这篇blog的目的是，学会自己写一个vue的插件，但是我们并不是教你写什么插件，只是简单展示一下，写一个插件相关的语法。 show me code plugin.html: 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue-plugin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt; &lt;p v-my-directive="msg"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/vue/2.5.15/vue.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="./plugin.js"&gt;&lt;/script&gt; &lt;script&gt; // 声明使用插件 Vue.use(MyPlugin) //内部会执行 MyPlugin.install(Vue) Vue.myGlobalMethod(); const vm = new Vue(&#123; el:'#test', data: &#123; msg: 'I want to do something' &#125; &#125;) vm.$myMethod() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; plugin.js: 12345678910111213141516171819202122232425262728293031323334(function () &#123; // 需要向外暴露的插件对象 const MyPlugin = &#123;&#125; // 插件对象 必须要有一个install的方法 MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... console.log('Vue 函数对象的方法myGlobalMethod') &#125; // 2. 添加全局资源 Vue.directive('my-directive', function(el,binding)&#123; el.textContent = binding.value.toUpperCase(); &#125;) // 3. 注入组件 //这个方法 这里暂时可以不适用 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... console.log('vue实例对象的方法$myMethod') &#125; &#125; // 向外暴露 window.MyPlugin = MyPlugin;&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-directive]]></title>
    <url>%2F2018%2F11%2F17%2F2018-11-17-vue%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[指令自定义指令 + 内置指令 v-text v-html v-if v-else v-for v-show v-on v-bind v-model ref v-cloak 防止闪现 内置定义123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;vue生命周期&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt; &lt;p ref="content"&gt;p text&lt;/p&gt; &lt;button @click="hint"&gt;alert&lt;/button&gt; &lt;p v-text="msg"&gt;&lt;/p&gt; &lt;p v-cloak&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.directive new vue(&#123; el: '#example', data: &#123; date: new Date() &#125;, methods: &#123; hint () &#123; alert(this.$refs.content.textContent) &#125; &#125; &#125;); //全局指令 //局部指令 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自定义123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;vue生命周期&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt; &lt;p v-upper-text="msg"&gt;&lt;/p&gt; &lt;p v-lower-text="msg"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 定义全局指令 Vue.directive('v-upper-text', function()) new vue(&#123; el: '#example', data: &#123; msg1:'waAdwdwade' &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 自定义12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Vue全局指令&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt; &lt;p v-upper-text="msg"&gt;&lt;/p&gt; &lt;p v-lower-text="msg"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 定义全局指令 // el:指令属性所在的标签对象 // binding:包含指令相关信息属性的对象 Vue.directive('v-upper-text', function(el, binding)&#123; el.textContent = binding.value.toUpperCase(); &#125;) new vue(&#123; el: '#example', data: &#123; msg1:'waAdwdwade' &#125;, // 局部指令 directives: &#123; 'lower-text': function(el, binding)&#123; el.textContent = binding.value.toLowerCase() &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hybrid 技术 简单了解]]></title>
    <url>%2F2018%2F07%2F17%2Fhybrid%E6%B7%B7%E5%90%88app%2F</url>
    <content type="text"><![CDATA[hybrid交互 JavaScript core == js bridge url schema 这里有一张图可以简单说明： 其实Hybrid的交互无非就2种方法： native调用前端页面中js方法 前端页面通过js调用native提供的接口 2个交互的bridge都是webview 从第一个开始讲解：web和native约定好，然后h5将一组api绑定在window对象上，app通过webview获取window对象然后调用js。这就是最初说的native调用页面中js的方法 第二个：web传递一个url，然后native那边可以截断url，通过url中的schema进行解析，然后做出相应的操作 然后app自身是可以自定义url schema的，并把自定义的url注册在调度中心，比如： weixin:// 打开微信 ctrip：//xx 打开携程 js与native通信：创建这类url，native将其捕获，然后进行操作。 api式交互native api接口和ajax调用服务器提供的接口非常相似 然后接下来这张图可以清楚的展示我们在设计hybrid交互模型的时候，通信的流程： 格式约定前面说了这个流程和ajax比较相似，这里就按照ajax做一个参考。 1234$.ajax(options) =&gt; XMLHttpRequesttype(default val：“get”) http请求方法（“get”，“post”，其他）url(default val：当前url) 请求url的地址data(default val：none) 与native约定的请求模型：123456789requestHybrid(&#123; //创建一个新的webview对话框窗口 tagname: 'hybridapi', //请求参数，会被Native使用 param: &#123;&#125;, //Native处理成功后回调前端的方法 callback: function (data) &#123; &#125;&#125;); 这个方法就会形成一个url，比如：hybridschema://hybridapi?callback=hybrid_1446276509894&amp;param=%7B%22data1%22%3A1%2C%22data2%22%3A2%7D 然后数据会得到返回，一般的格式是这样的：12345&#123; data: &#123;&#125;, errno: 0, msg: "success"&#125; code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657window.Hybrid = window.Hybrid || &#123;&#125;;var bridgePostMsg = function (url) &#123; if ($.os.ios) &#123; window.location = url; &#125; else &#123; var ifr = $('&lt;iframe style="display: none;" src="' + url + '"/&gt;'); $('body').append(ifr); setTimeout(function () &#123; ifr.remove(); &#125;, 1000) &#125;&#125;;var _getHybridUrl = function (params) &#123; var k, paramStr = '', url = 'scheme://'; url += params.tagname + '?t=' + new Date().getTime(); //时间戳，防止url不起效 if (params.callback) &#123; url += '&amp;callback=' + params.callback; delete params.callback; &#125; if (params.param) &#123; paramStr = typeof params.param == 'object' ? JSON.stringify(params.param) : params.param; url += '&amp;param=' + encodeURIComponent(paramStr); &#125; return url;&#125;;var requestHybrid = function (params) &#123; //生成唯一执行函数，执行后销毁 var tt = (new Date().getTime()); var t = 'hybrid_' + tt; var tmpFn; //处理有回调的情况 if (params.callback) &#123; tmpFn = params.callback; params.callback = t; window.Hybrid[t] = function (data) &#123; tmpFn(data); delete window.Hybrid[t]; &#125; &#125; bridgePostMsg(_getHybridUrl(params));&#125;;//获取版本信息，约定APP的navigator.userAgent版本包含版本信息：scheme/xx.xx.xxvar getHybridInfo = function () &#123; var platform_version = &#123;&#125;; var na = navigator.userAgent; var info = na.match(/scheme\/\d\.\d\.\d/); if (info &amp;&amp; info[0]) &#123; info = info[0].split('/'); if (info &amp;&amp; info.length == 2) &#123; platform_version.platform = info[0]; platform_version.version = info[1]; &#125; &#125; return platform_version;&#125;;]]></content>
      <categories>
        <category>Hybrid</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 常见命令]]></title>
    <url>%2F2018%2F07%2F10%2Fhello-hexo%20%E4%B8%8B%E5%8D%883.56.56%2F</url>
    <content type="text"><![CDATA[git常见命令先讲讲如何clone一个远程repertory。 1$ git clone xxx(repertory ssh地址) 接下来讲讲分支相关的命令。 新建一个分支，并切换到该分支： 1$ git checkout -b xx(branch name) 查看分支： 1$ git branch 查看远程所有分支： 1$ git branch -a 删除分支： 1$ git branch -d xxx(branch name) 如何进行回退 回退版本：1$ git reset --hard version(commit number) 查看状态 查看状态1$ git status 添加更新，推上去 保存1$ git add . (这是将所有修改过的工作文件提交暂存区) 1$ git add (将工作文件修改提交到本地暂存区) commit 1$ git commit -m &apos;xxx&apos;(里面是修改的信息的info) push 1$ git push xxx(该仓库的ssh地址) 合并某分支到当前分支1$ git merge xx(name) 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改1$ git reset --hard 打开ssh文件1$ cat ~/.ssh/id_rsa.pub]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F05%2F08%2Fflex%2F</url>
    <content type="text"><![CDATA[flex布局之前学 react native 的时候接触过 flex，这次又系统的练习了一次，更加熟悉。这里推荐阮一峰flex 实战 这篇文章flex 的语法篇 之前面试滴滴的时候问到了 flex：1 的意思当时竟然没回答上来。flex 是 flex grow flex shrink flex basis 的简写 可以写 flex：1 1 auto 后两项为可选项flex1 就是按个数等比分配flex2 就是 2 倍 flex 常用点上下居中，给父盒子设置 12display: flex;align-items: center; // 上下居中 左右居中 12display:flex;justify-content: center; notice今天在做一个模块的时候，发现 pc 端和移动端，或者这么说在 Chrome 和 Safari 上的展示效果有些区别，然后发现了一个新用法： 1flex: none; 当你不希望自己的 dom 或者 el 被 flex 压缩时，加这个，非常好使 既然都讲到了这里，顺便记录 2 行样式，用于多行省略使用，还是挺常用的： 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; // 数字可变，2表示2行后 + ...]]></content>
      <categories>
        <category>踩坑记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 对象理解]]></title>
    <url>%2F2018%2F05%2F04%2F2018-05-04-JS%20%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简单梳理一下对象的意义: 什么是对象？ 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 为什么要用对象？ 统一管理多个数据 对象的组成 属性：属性名（字符串）和属性值（任意）组成 方法：一种特别的属性（属性值是函数） 如何访问对象内部数据？ .属性名：编码简单，有时不能用 [‘属性名’]:编码麻烦，能通用 简单代码演示:1234567891011121314var p = &#123; name: &apos;Tom&apos;, age: 12, setName: function (name) &#123; this.name = name &#125;, setAge: function (age) &#123; this.age = age &#125;&#125;p.setName(&apos;Bob&apos;)p[&apos;setAge&apos;](23)console.log(p.name, p[&apos;age&apos;]) 问题：什么时候必须使用[‘属性名’]的方式? 1.属性名包含特殊字符:- 空格 2.属性名不确定 1234567891011121314 var p = &#123;&#125; //1. 给p对象添加一个属性: content type: text/json // p.content-type = &apos;text/json&apos; //不能用 p[&apos;content-type&apos;] = &apos;text/json&apos; console.log(p[&apos;content-type&apos;])//输出:text/json //2. 属性名不确定 var propName = &apos;myAge&apos; var value = 18 // p.propName = value //不能用 p[propName] = value console.log(p[propName])//输出:18]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据-变量-内存 详解]]></title>
    <url>%2F2018%2F05%2F03%2F2018-05-03-%E6%95%B0%E6%8D%AE-%E5%8F%98%E9%87%8F-%E5%86%85%E5%AD%98%20%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这篇文章主要详解讲解 数据-变量-内存的详细意义，同时理一理它们之间的关系。 什么是数据？ 我们可以这样理解：存储于内存中代表特定信息的‘东东’。本质就是0101..二进制 具有可读和可传递的基本特性 万物（一切）皆数据，函数也是数据 程序中所有操作的目标：数据 算术运算 逻辑运算 赋值 调用参数传参 函数运行，类似:foo () 这里可以把()当做运行标识符操作 什么是内存？ 内存条通电后产生的存储空间（临时的） 产生和死亡：内存条（集成电路板）===&gt;通电===&gt;产生一定容量的存储空间===&gt;存储各种数据===&gt;断电===&gt;内存全部消失 内存的空间是临时的，而硬盘的空间是持久的，但是内存的效率高于硬盘，各有优缺 分配内存：声明变量和函数或创建对象的时候，JS引擎会自动为此分配一定大小的内存来存放对应的数据 释放内存：清空内存中的数据，标识内存可以再分配使用（内存不释放就不能复用） 自动释放：栈空间的局部变量 垃圾回调器回调：堆空间的垃圾对象 一块内存包含2个数据 内存存储的数据（一般数据/地址数据） 内存地址值数据 内存分类 栈：全局变量，局部变量（这些空间较小） 堆：对象（空间较大，还可以用于存放代码等） 什么是变量？ 值可以变化的量，由变量名与变量值组成 一个变量对应一块小内存，变量名用来查找到内存，变量值就是内存中保存的内容 内存-数据-变量三者之间的关系 内存是一个容器，用于存储程序运行需要操作的数据 变量是内存的标识，我们通过变量找到相应的内存，进而操作（读/写）内存中的数据 简单代码演示:1234var a1 = 3 //这个就是基础数据类型 var a2 = a1 + 4 //这里的al就是3，然后进行算术计算 var a3 = &#123;&#125; //这个就是引用类型，a3里面是对象的地址 a3.name = &apos;Tom&apos; //name相当于对象中TOM这个值的标识名 #关于赋值和内存的问题 这里先扔出一个问题： 问题：var a=xxx，a内存中保存的是什么？ xxx是一个基本数据 xxx是一个对象 xxx是一个变量 简单代码演示:123456789var a = 3 //a内存中保存的就是3 a = function () &#123; &#125; ///a内存保存的是对象的地址var b = &apos;abc&apos; //b内存中保存的是‘abc’a = b //a内存保存的就是b内存的内容，即‘abc’b = [] //b内存保存的是array的地址a = b //a内存保存的就是b内存的内容，即array的地址 #关于引用变量赋值问题 关于引用变量赋值问题 2个引用变量指向同一个对象，通过一个引用变量修改对象内部数据，另一个引用变量也看得见 2个引用变量指向同一个对象，让一个引用变量指向另一个对象，另一个引用变量还是指向原来的对象 1234567891011121314151617 //1. 2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见 var obj1 = &#123;&#125; var obj2 = obj1 obj2.name = &apos;Tom&apos; console.log(obj1.name) //输出Tom function f1(obj) &#123; obj.age = 12 &#125; f1(obj2) console.log(obj1.age)//输出 12 //2. 2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象 var obj3 = &#123;name: &apos;Tom&apos;&#125; var obj4 = obj3 obj3 = &#123;name: &apos;JACK&apos;&#125; console.log(obj4.name) //输出 Tom #关于数据传递问题 问题：在js调用函数时传递变量参数时，是值传递还是引用传递 只有值传递，没有引用传递，传递的都是变量的值，只是这个值可能是基本数据，也可能是地址（引用）数据 如果后一种看成是引用传递，那值传递和引用传递都可以有 简单代码演示:1234567891011121314 function f(a) &#123; console.log(a) &#125; var n = 4 f(n) //传递的是n的值 ---&gt;值传递//输出4 function f2(a) &#123; a.name = &apos;atguigu&apos; &#125; n = &#123;&#125; f2(n) // 传递的是n指向的对象 ---&gt; 引用传递 ??? 传的智商n里面的内容 也就是&#123;&#125;的地址 console.log(n.name) //输出atguigu #JS引擎如何管理内存？ 内存生命周期 分配需要的内存 使用分配到的内存 不需要时将其释放/归还 释放内存 为执行函数分配的栈空间内存：函数执行完自动释放 存储对象的堆空间内存：当内存没有引用指向时，对象成为垃圾对象，垃圾回收器后面就会回收释放此内存 12345678910 var obj = &#123;&#125; obj = null // ?//内存还有obj，并且它的值为null function fn () &#123; var a = 3 var b = &#123;&#125; &#125; fn() // ? //内存中已经没有a和b了 但是有fn]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[理解数据类型]]></title>
    <url>%2F2018%2F05%2F02%2F2018-05-02-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[很多时候，我们都用到了数据，却没能完全理解他的一些类型，这里总结一下常见的容易错的点。 分类（2大类） 基本值类型 Number:任意数值 String:任意文本 Boolean:true/false undefined:undefined null:null 对象（引用）类型 Object：一般对象类型 Array：特别的对象类型（下标/内部数据有序） Function：特别的对象类型（可执行，类似于foo(),这里的()相当于执行标识符） 判断 typeof: 可以区别：数值、字符串、布尔值、undefined、function 不能区分：null与对象，一般对象与数组 instanceof 专门用来判断对象数据的类型：Object、Array与Function === 可以判断undefined和null undefined与null的区别？ undefined代表只申明了没有赋值 null代表赋值了, 只是值为null 什么时候给变量赋值为null呢？ var a=null //a将指向一个对象，但是对象此时还没确定 a=null //让a指向的对象变成垃圾对象 严格区别变量类型与数据类型？ js的变量本身是没有类型的，变量的类型实际上是变量内存中的数据的类型 变量类型： 基本类型：保存基本类型数据的变量 引用类型：保存对象地址值的变量 数据对象 基本类型 对象类型 这里我想简单引申一下堆和栈的概念，一般来说栈里面是保存2个东西：1.全局变量 2.局部变量 ；但是在堆里面只保存对象。 简单代码演示:123456789101112131415161718// 1. undefined与null的区别? var a1 var a2 = null console.log(a1, a2) //输出 undefined null // 2. 什么时候给变量赋值为null呢? //初始 var a3 = null //中间 var name = &apos;Tom&apos; var age = 12 a3 = &#123; name: name, age: age &#125; //结束 a3 = null]]></content>
      <categories>
        <category>前端面试</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS this的理解与运用]]></title>
    <url>%2F2018%2F05%2F01%2F2018-05-01-JS%20this%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在函数执行的时候，this总是指向调用该函数的对象。要判断this的指向，其实就是判断this所在的函数属于谁。 在《JavaScript语言精粹》这本书中，把this出现的场景分为4类，简单说就是： ###1. 有对象 就指向调用对象1234567var myObject = &#123;value:100&#125;; myObject.getValue = function()&#123; console.log(this.value);//输出100 console.log(this);//输出 &#123; value: 100, getValue: [Function] &#125; &#125; myObject.getValue(); // getValue() 属于对象 myObject，并由 myOjbect 进行 . 调用，因此 this 指向对象 myObject。 ###2.没调用对象就指向全局对象123456789101112var myObject = &#123; value: 100 &#125;; myObject.getValue = function() &#123; var foo = function() &#123; console.log(this.value) // 输出 undefined console.log(this); // 输出全局对象 global //foo 函数虽然定义在 getValue 的函数体内，但实际上它既不属于 getValue 也不属于 myObject。 // foo 并没有被绑定在任何对象上，所以当调用时，它的 this 指针指向了全局对象 global。 &#125;; foo(); return this.value; //这个this 在 getValue中，从而指向 myObject。 &#125;; console.log(myObject.getValue()); // 输出 100 3) 用new构造就指向新对象123456//js 中，我们通过 new 关键词来调用构造函数，此时 this 会绑定在该新对象上。 var SomeClass = function() &#123; this.value = 100; &#125; var myCreate = new SomeClass(); console.log(myCreate.value); // 输出10 4) 通过 apply 或 call 或 bind 来改变 this 的所指1234567891011121314151617// apply 和 call 调用以及 bind 绑定： 指向绑定的对象 // apply() 方法接受两个参数第一个是函数运行的作用域， 另外一个是一个参数数组(arguments)。 // call() 方法第一个参数的意义与 apply() 方法相同， 只是其他的参数需要一个个列举出来。 // 简单来说， call 的方式更接近我们平时调用函数， 而 apply 需要我们传递 Array 形式的数组给它。 它们是可以互相转换的。 //apply和call的功能是一样的，只是传入的参数列表形式不同。//var a1 = add.apply(sub,[4,2]); //sub调用add的方法/*call的用法*///var a1 = add.call(sub,4,2);var myObject = &#123; value: 100 &#125;; var foo = function() &#123; console.log(this); &#125;; foo(); // 全局变量 global foo.apply(myObject); // &#123; value: 100 &#125; foo.call(myObject); // &#123; value: 100 &#125; var newFoo = foo.bind(myObject); newFoo(); // &#123; value: 100 &#125;&lt;/span&gt;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BFC来清除浮动]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-BFC%E6%9D%A5%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[BFC 就是块级格式化上下文 想必大家都不陌生了 BFC的渲染规则有4个: BFC元素在垂直方向上，会发生边距重叠现象 BFC的区域是不会与float 浮动元素的区域发生重叠，这个主要是用于解决清除浮动，下面会用代码讲解这个 BFC是一个独立的容器，里面不会影响外面，外面也不会影响里面 BFC元素在计算高度的时候，是会把浮动元素的高度计算进去的。 ####说了这么多，先简单讲讲BFC如何清除浮动的吧123456789101112131415161718192021222324252627282930313233&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Clear float&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .container&#123; margin: 30px auto; width:600px; height: 300px; &#125; .p&#123; border:solid 3px #a33; &#125; .c&#123; width: 100px; height: 100px; background-color: #060; margin: 10px; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;p&quot;&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行出来的效果是这样的: 因为浮动元素是脱离文档流的，不占文档流的位置，所以这里的上下边距最后重合了，怎么解决这个问题呢？ 在这里引用BFC的第二点渲染规则 BFC区域是不会与浮动元素区域重叠的 1234.p&#123; border:solid 3px #a33; overflow: hidden; &#125; 这时候，我们将p设置为BFC后，效果如下: from:https://www.cnblogs.com/dolphinX/p/3508869.html]]></content>
      <categories>
        <category>css</category>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css相关]]></title>
    <url>%2F2018%2F04%2F27%2F2018-04-27-css%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是CSS 预处理器 / 后处理器？ 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms CSS3有哪些新特性？ 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 缩放,定位,倾斜,动画,多背景 例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation: position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值 https://github.com/poetries/FE-Interview-Questions/blob/master/Interview-Questions/Front-end-Developer-Questions%5Bquestion-and-answer-version%5D.md 用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） #demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; } 为什么要初始化CSS样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） 想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。 让页面里的字体变清晰，变细用CSS怎么做？ -webkit-font-smoothing: antialiased; font-style属性可以让它赋值为“oblique” oblique是什么意思？ 倾斜的字体样式 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms css居中的几种方法： https://juejin.im/entry/58aaaf03ac502e006972fd75]]></content>
      <categories>
        <category>css</category>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js详解]]></title>
    <url>%2F2018%2F04%2F25%2F2018-04-25-Node.js%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Node.js 最重要的3点：1.单线程单线程的好处：减少了内存开销，就像操作系统中的内存换页。2.非阻塞I/O如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。不会傻等I/O语句结束，而会执行后面的语句。非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？ 由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。 3.event-driven事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。 说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。Node.js中所有的I/O都是异步的，回调函数，套回调函数。 事件驱动event-driven在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度 Node.js适合开发什么？善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。 当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。 昨天面腾讯的时候，面试官提到了如何用node中的http模块搭建一个服务器。 1234567var http=require('http');var server=http.createServer(function (req,res) &#123; res.send("你好");&#125;)server.listen(3000,"127.0.0.1"); 又问了一个问题，如果用node搭建websocket]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[restful浅谈]]></title>
    <url>%2F2018%2F04%2F24%2F2018-04-24-restful%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[简单来说，restful就是把操作的动作交给http的对应方法来识别，get:获取，post:创建，put:更新，delete:删除。 这样同一个uri可能标识多个动作。在前台处理方面，其实form表单是只支持get,和post,如果需要支持put、delete等。 各个支持rest的框架应该都有处理，比如spring MVC的HiddenHttpMethodFilter就是来解决这个的，也可以ajax处理。之于这样的好处，其他的可能要在实战中体会。 一般WEB应用的API会被设计成restful方式, API操作的东西叫资源, 操作的方式就是请求的方式(GET, POST, DELTE, PUT) 把每一个请求看成是对资源的访问， 用一些动词表达对资源的操作（增、删、查、改) /GET/id/{id} //获取资源 /POST //创建资源 /PUT //更新资源 /DELET/id/{id} //删除资源]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[H5 web workers（多线程）]]></title>
    <url>%2F2018%2F04%2F23%2F2018-04-23-H5%20web%20workers%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[#介绍 web workers是HTML5提供的一个JavaScript多线程解决方案 我们可以将一些大计算量的代码交由web worker运行而不冻结用户界面 但是子线程完全受主线程控制，且不得操作dom。所以，这个新标准并没有改变JavaScript单线程的本质。 ###相关：1.h5规范提供了js分线程的实现，取名为web workers2.相关API woker：构造函数，加载分线程执行的js文件 Woker.prototype.onmessage:用于接收另一个线程的回调函数 Woker.prototype.postMessage:向另一个线程发送消息 不足 worker内代码不能操作DOM(更新UI) 不能跨域加载JS 不是每个浏览器都支持这个新特性 #使用 创建在分线程执行的js文件 在主线程中的js中发消息并设置回调1234567891011121314&lt;input type=&quot;text&quot; id=&quot;number&quot; value=&quot;30&quot;&gt; &lt;button id=&quot;btn1&quot;&gt;主线程计算fibonacci值&lt;/button&gt; &lt;button id=&quot;btn2&quot;&gt;分线程计算fibonacci值&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var worker = new Worker(&quot;./worker·2.js&quot;); document.getElementById(&quot;btn2&quot;).onclick = function() &#123; var inputVal = document.getElementById(&quot;number&quot;).value; worker.postMessage(inputVal); worker.onmessage = function(event) &#123; console.log(event.data); &#125; &#125; &lt;/script&gt; worker2.js:123456789var fibonacci =function(n) &#123; return n &lt;2 ? n : fibonacci(n -1) + fibonacci(n -2);&#125;;var onmessage = function(event) &#123; console.log(event); var n = parseInt(event.data, 10); postMessage(fibonacci(n));&#125;; 贴上相关API分线程接收12345var onmessage =function (event)&#123; //不能用函数声明 console.log(&apos;onMessage()22&apos;); var upper = event.data.toUpperCase();//通过event.data获得发送来的数据 postMessage( upper );//将获取到的数据发送会主线程&#125; 在主线程设置12345678创建一个Worker对象并向它传递将在新线程中执行的脚本的URLvar worker = new Worker(&quot;worker.js&quot;); //接收worker传过来的数据函数worker.onmessage = function (event) &#123; console.log(event.data); &#125;;//向worker发送数据worker.postMessage(&quot;hello world&quot;); 相应图解：]]></content>
      <categories>
        <category>前端面试</category>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计网基础知识]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[今天看到一段文字是描写dns的，感觉写的很棒，在这里记录一下。 DNS的使命 DNS(Domain Name System),中文叫做域名系统。 DNS的就是为了同时保留域名和IP地址的优势的产物。人们可以通过域名简单的记住要访问的web站点，而路由器等网络设备却可以使用IP地址快速定位到相关主机。DNS要做的就是当用户输入域名后，先到DNS服务器查询IP地址，然后再通过IP地址来访问web站点。 从浏览器地址栏输入url到显示页面的步骤 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；载入解析到的资源文件，渲染页面，完成。这盘文章图解http 讲解的非常的到位https://juejin.im/entry/587230c6ac502e006c21a6e8]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js advance(1)]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-js%20advance(1)%2F</url>
    <content type="text"><![CDATA[最近准备好好啃一啃js，一步一步来。 #线程机制与事件机制 ##进程与线程 进程（process）的基本概念: 程序的一次执行，它占有一片独有的内存空间 可以通过windows任务管理器查看进程 进程被称为cpu的最小资源单位 线程（thread）的基本概念： 是进程内的一个独立执行单位 是程序执行的一个完整的流程 是cpu的最小的调度单元 放上一张图，可以更加简单的了解，这2个之间的关系： 进程与线程的相关知识： 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程：主线程（既然有主线程肯定就有分线程这个说法），主线程是，进程启动后自动创建的 一个进程中也可以同时运行多个线程，我们会说程序是多个线程运行的 一个进程中的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能共享的 线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用（复用性） 有时候会问到跟进程与线程相关的问题，在这里总结一下。 1.何为多进程与多线程？多进程运行：一个应用程序可以同时启动多个实例运行。多线程运行：在一个进程内，同时有多个线程运行。 2.比较单线程与多线程？ 多线程优点：有效提升cpu的利用率缺点：1.创建多线程会增加开销； 2线程切换也会有开销； 3.死锁与状态同步问题 单线程优点：顺序编程 简单易懂缺点：效率低 3.JS是单线程还是多线程？ js是单线程运行的 H5中的web workers可以多线程运行 4.浏览器运行是单线程还是多线程？都是多线程 5.浏览器运行是单进程还是多进程？ 有的是单进程。比如：Firefox和老版本的IE 有的是多进程：比如：chrome和新版IE 如何查看浏览器是否是多线程运行的呢？通过任务管理器–&gt;查看进程#浏览器内核 浏览器内核就是支撑浏览器运行的最核心的程序 不同的浏览器 内核可能不一样 这里举几个例子Chrome，Safari：webkitfirefox：GeckoIE：Trident360、搜狗等国内浏览器：Trident+webkit这里说一句题外话，国产浏览器称自己为双核，其实就是用了2个内核，还是比较垃圾。在正常显示网页的时候，国产浏览器使用的内核是webkit，当涉及到金钱交易的时候会把内核设置为Trident，IE的内核对安全性要求比较高。 内核是由很多模块组成的，下面简单列举一下js引擎模块：负责js程序的编译与运行html，css文档解析模块：负责页面文本的解析DOM/CSS模块：负责dom/css在内存中的相关处理（这里相当于把解析后的文档抽象成数据结构，例如domtree cssomtree）布局和渲染模块：负责页面的布局和效果绘制以上这4个可以称为主线程。…还有很多模块 这里就不过多提及。下面说3个比较典型的3个分线程：定时器模块：负责定时器的管理Dom事件响应模块：负责事件的管理网络请求模块：负责ajax请求这里我把分线程理解为异步。附上一张图，简单明了：#定时器引发的思考 定时器真是定时执行的吗? 定时器并不能保证真正定时执行 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)1234567891011var start = Date.now() console.log(&apos;启动定时器前...&apos;) setTimeout(function() &#123; console.log(&apos;定时器执行了&apos;, Date.now() - start) &#125;, 200) console.log(&apos;启动定时器后...&apos;) // 做一个长时间的工作 for(var i = 0; i &lt; 1000000000; i++) &#123; &#125; 这是输出： 定时器回调函数是在哪个线程执行的? 在主线程执行的, js是单线程的 这里可以这么说，先执行同步任务再执行异步任务，异步任务包括（promise的回调，dom的回调，settimeout的回调等） 定时器是如何实现的? 事件循环模型 #JS是单线程执行的 如何证明js执行是单线程的? setTimeout()的回调函数是在主线程执行的 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行 为什么js要用单线程模式, 而不用多线程模式? JavaScript的单线程，与它的用途有关。 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。 这决定了它只能是单线程，否则会带来很复杂的同步问题。这里简单举一个例子来说明，假如js是多线程的，那么线程p1和线程p2都可以对dom进行操作，如果p1的操作是更改dom，p2的操作是删除dom，那能一边删除一边更改么- - 代码的分类 初始化代码 回调代码这是一种分法，我也喜欢分为同步任务+异步任务 js引擎执行代码的基本流程 先执行初始化代码: 包含一些特别 的代码 回调函数(异步执行) 设置定时器 绑定事件监听 发送ajax请求 后面在某个时刻才会执行回调代码1234567891011121314151617181920setTimeout(function() &#123; console.log(&apos;timeout 2222&apos;) alert(&apos;22222222&apos;) &#125;, 2000) setTimeout(function() &#123; console.log(&apos;timeout 1111&apos;) alert(&apos;1111111&apos;) &#125;, 1000) setTimeout(function() &#123; console.log(&apos;timeout() 00000&apos;) &#125;, 0) function fn() &#123; console.log(&apos;fn()&apos;) &#125; fn() console.log(&apos;alert()之前&apos;) alert(&apos;------&apos;) //暂停当前主线程的执行, 同时暂停计时, 点击确定后, 恢复程序执行和计时 console.log(&apos;alert()之后&apos;) 输出：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试题总结]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTTP web综合问题 1.Html5语义化理解 用正确的标签做正确的事html语义化就是让页面的内容结构化，便于浏览器、搜索引擎解析在没有样式 CSS 情况下也可以以一种文档格式显示，可读性强让阅读源代码的人 更容易将网站分块 便于阅读维护理解2.HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;？ html5 不需要对DTD（document type definition）进行引用，但是需要doctype来规范浏览器行为CSS部分 1.css优先级 载入样式以最后载入的定位为准 优先级为:!important&gt;行内&gt;id&gt;class&gt;tag&gt;通配符&gt;继承&gt;默认 https://blog.csdn.net/qq_28300493/article/details/52297165 说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 用过哪些设计模式？ 工厂模式工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字构造函数模式使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于直接将属性和方法赋值给 this对象;length的巧妙用法 var arr1=arr2=[1,2,3]; //清空数组 arr1.length=0; console.log(arr1,arr2); //output &apos;&apos; &apos;&apos; //截断array arr1.length=1; console.log(arr1,arr2); //output [1] 合并数组的巧妙方法 //普通方法 concatarr1=[1,2,3][1, 2, 3]arr2=[4,5,6][4, 5, 6]arr1.concat(arr2)[1, 2, 3, 4, 5, 6]//用pushlet arr1 = [1, 2, 3, 4, 5];let arr2 = [6, 7, 8, 9, 10]; Array.prototype.push.apply(arr1, arr2);判断是否为数组 //在es5中isArray方法 Boolean//其他方法array.prototype.toString==”object array”]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iframe浅谈]]></title>
    <url>%2F2018%2F04%2F19%2F2018-04-19-iframe%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[关于iframe 下面是W3School对的定义：iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。不过按我的理解就是：iframe提供了一个简单的方式吧一个网站的内容嵌入到另一个网站中。 那iframe一般用在什么方面呢？ 目前用得最多的是管理后台类网站，左边一个菜单list，右边就是iframe的tabs,可以随时打开、关闭页面。在这种系统中，如果把iframe替换成div，那么大量页面中相同类型的表格、表单等就要用不同的id、class。因为js是针对body下的所有对象的，所以这种系统用iframe比较好。可以在iframe里面自由使用js和标签id的定义，而且父页面和菜单列表一般不会刷新，所以iframe带来的内容也就和一般页面的刷新一样。 如果我们需要独立的浏览上下文，那就用iframe，否则不用。 iframe常被用于复用部分界面，比较早期的网站使用 iframe，主要是用于导航栏（navigator）。为什么？因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。同时带来的不利是，默认情况下，使用了 iframe 的网站的 URL 不会随着页面的变化而变化。这就意味着一旦刷新，网站可能又回到首页。 那么现在什么时候会用到 iframe 呢？因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。 iframe的优点 隔离上下文，便于更改，模块分离iframe的缺点 iframe会阻塞主页面的Onload事件搜索引擎的检索程序无法解读这种页面，不利于SEOiframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js基础点]]></title>
    <url>%2F2018%2F04%2F17%2F2018-04-17-js%E5%9F%BA%E7%A1%80%E7%82%B9%2F</url>
    <content type="text"><![CDATA[介绍js的基本数据类型 Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) 如何将字符串转化为数字，例如’12.3b’? parseFloat(‘12.3b’); Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[websocket]]></title>
    <url>%2F2018%2F04%2F15%2F2018-04-15-websocket%2F</url>
    <content type="text"><![CDATA[#HTTP无法轻松实现实时应用： HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。 我们可以非常轻松的捕获浏览器上发生的事件（比如用户点击了盒子），这个事件可以轻松产生与服务器的数据交互（比如Ajax）。但是，反过来却是不可能的：服务器端发生了一个事件，服务器无法将这个事件的信息实时主动通知它的客户端。只有在客户端查询服务器的当前状态的时候，所发生事件的信息才会从服务器传递到客户端。 但是，确实聊天室确实存在。方法有2个： 长轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果（想象一下我们没有写res.end()时，浏览器一直转小菊花）。服务器有了新数据，就将数据发回来，又有了新数据，就将数据发回来，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。 ###WebSocket协议能够让浏览器和服务器全双工实时通信，互相的，服务器也能主动通知客户端了。 WebSocket的原理非常的简单：利用HTTP请求产生握手，HTTP头部中含有WebSocket协议的请求，所以握手之后，二者转用TCP协议进行交流（QQ的协议）。现在的浏览器和服务器之间，就是QQ和QQ服务器的关系了。 所以WebSocket协议，需要浏览器支持，更需要服务器支持。 支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5 支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3 ###Node.js上需要写一些程序，来处理TCP请求。 Node.js从诞生之日起，就支持WebSocket协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库Socket.IO。 Socket.IO是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持WebSocket协议的浏览器，提供了长轮询的透明模拟机制。 Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器 ###写原生的JS，搭建一个服务器，server创建好之后，创建一个io对象 12345678910111213141var http = require(&quot;http&quot;);23var server = http.createServer(function(req,res)&#123;4 res.end(&quot;你好&quot;);5&#125;);67var io = require(&apos;socket.io&apos;)(server);//监听连接事件io.on(&quot;connection&quot;,function(socket)&#123; console.log(&quot;1个客户端连接了&quot;);&#125;)8server.listen(3000,&quot;127.0.0.1&quot;); 写完这句话之后，你就会发现，http://127.0.0.1:3000/socket.io/socket.io.js 就是一个js文件的地址了。 现在需要制作一个index页面，这个页面中，必须引用秘密js文件。调用io函数，取得socket对象。12345678910111213141&lt;!DOCTYPE html&gt;2&lt;html lang=&quot;en&quot;&gt;3&lt;head&gt;4 &lt;meta charset=&quot;UTF-8&quot;&gt;5 &lt;title&gt;Document&lt;/title&gt;6&lt;/head&gt;7&lt;body&gt;8 &lt;h1&gt;我是index页面，我引用了秘密script文件&lt;/h1&gt;9 &lt;script type=&quot;text/javascript&quot; src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;10 &lt;script type=&quot;text/javascript&quot;&gt;11 var socket = io();12 &lt;/script&gt;13&lt;/body&gt;&lt;/html&gt; 此时，在服务器上，app.js中就要书写静态文件呈递程序，能够呈递静态页面。123456781var server = http.createServer(function(req,res)&#123;2 if(req.url == &quot;/&quot;)&#123;3 //显示首页4 fs.readFile(&quot;./index.html&quot;,function(err,data)&#123;5 res.end(data);6 &#125;);7 &#125;&#125;); ####至此，服务器和客户端都有socket对象了。服务器的socket对象： 服务器端:1234567891var io = require(&apos;socket.io&apos;)(server);2//监听连接事件3io.on(&quot;connection&quot;,function(socket)&#123;4 console.log(&quot;1个客户端连接了&quot;);5 socket.on(&quot;tiwen&quot;,function(msg)&#123;6 console.log(&quot;本服务器得到了一个提问&quot; + msg);7 socket.emit(&quot;huida&quot;,&quot;吃了&quot;);8 &#125;);&#125;); 每一个连接上来的用户，都有一个socket。 由于我们的emit语句，是socket.emit()发出的，所以指的是向这个客户端发出语句。 广播，就是给所有当前连接的用户发送信息： 123456789101//创建一个io对象 2var io = require(&apos;socket.io&apos;)(server);3//监听连接事件4io.on(&quot;connection&quot;,function(socket)&#123;5 console.log(&quot;1个客户端连接了&quot;);6 socket.on(&quot;tiwen&quot;,function(msg)&#123;7 console.log(&quot;本服务器得到了一个提问&quot; + msg);8 io.emit(&quot;huida&quot;,&quot;吃了&quot;);9 &#125;);&#125;);]]></content>
      <categories>
        <category>websocket</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[react小记]]></title>
    <url>%2F2018%2F01%2F31%2F2018-01-31-react%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[时隔半年，再次复习一下react 刚刚自己画了个react生命周期图，简版： 顺便画了个react 技术栈的思维导图： 最后再提一提web component 这是一个规范 组件主要考虑2点：1.可复用 2.可维护]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js爬知乎数据并分析]]></title>
    <url>%2F2018%2F01%2F30%2F2018-01-30-node%E7%88%AC%E7%9F%A5%E4%B9%8E%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前段时间看了一节公开课，教的是用node.js来爬知乎的数据。下面会给出github地址，也会附上代码，简单记录一下自己踩过的坑。https://github.com/zhangjing9898/crawler这是爬问题的函数123456789101112131415async function getQuestion(db, id) &#123; let res = await rp(&#123;url: `https://www.zhihu.com/question/$&#123;id&#125;`&#125;); let $ = cheerio.load(res); let data = $(&apos;#data&apos;).attr(&apos;data-state&apos;); let state = JSON.parse(htmlDecode(data)); let question = state.entities.questions[id]; db.collection(&quot;questions&quot;) .insert(question) console.log(`question id : $&#123;id&#125; insert into db`) await getAnswers(db, id, question.answerCount)&#125; 这是爬该问题的评论数12345678910111213async function getAnswers(db, id, answerCount) &#123; for (let offset = 0; offset &lt; answerCount; offset += 20) &#123; let res = await rp(&#123; url: `https://www.zhihu.com/api/v4/questions/$&#123;id&#125;/answers?sort_by=default&amp;include=data%5B%2A%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Crelevant_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cupvoted_followees%3Bdata%5B%2A%5D.mark_infos%5B%2A%5D.url%3Bdata%5B%2A%5D.author.follower_count%2Cbadge%5B%3F%28type%3Dbest_answerer%29%5D.topics&amp;limit=20&amp;offset=$&#123;offset&#125;`, headers: &#123; authorization: &quot;oauth c3cef7c66a1843f8b3a9e6a1e3160e20&quot; &#125; &#125;) let data = JSON.parse(res); let answers = data.data; db.collection(&quot;answers&quot;).insertMany(answers); &#125;&#125; 这是main·函数：12345678910111213141516171819202122232425262728293031323334353637383940414243async function main() &#123; let url = &apos;mongodb://localhost:27017/crawler&apos;; let db = await MongoClient.connect(url); for(let id=30000000;id&lt;40000000;id++)&#123; try &#123; await getQuestion(db,id); &#125;catch (err)&#123; console.log(`question id : $&#123;id&#125;`); &#125; &#125; //爬知乎数据，详细版： // let url=&quot;mongodb://localhost:27017/crawler&quot;; // let db=await MongoClient.connect(url); // // await Promise.map( // [...range(start,end)], // async i=&gt;&#123; // try&#123; // await retry(async()=&gt;&#123; // let question=await db.collection(&apos;questions&apos;).findOne(&#123;id:i&#125;); // if(question)&#123; // console.log(`question id：$&#123;i&#125; already exists,skip`) // &#125;else&#123; // try &#123; // await Promise.resolve(getQuestion(db,i)).timeout(20000); // &#125;catch(err)&#123; // if(err.name==&apos;StatusCodeError&apos;)&#123; // return console.log(`question id：$&#123;i&#125; StatusCodeError is $&#123;err.statusCode&#125;`) // &#125; // console.log(`question id：$&#123;i&#125; error occur,$&#123;err.name&#125;,retry......`); // throw err; // &#125; // &#125; // &#125;,&#123;max_tries:10,interval:2000&#125;) // &#125;catch (err)&#123; // console.log(`question id： $&#123;i&#125; retry fail,drop`) // &#125; // &#125;, // &#123;concurrency:50&#125; /*控制并发数*/ // )&#125;main().catch(err =&gt; console.log(err)) 数据爬出来了，下一步就是将它可视化展示，这里用到了echarts，其实用图表展示可以使用echarts或者d3，d3展示的图类更加丰富，同时难度大于echarts，所以这里用的vue-echarts，用了vue的脚手架来构建，下面会给出github地址。坑：1.vue的脚手架下 使用eslintrc规范，如果不想使用这种规范，可以在config目录下的index.js的useEslint: 设置为false。2.在对数据库中的数据进行聚合已经分类等的时候，我用了mongovue中的aggravate。下面来记录一哈步骤：1234567891011121314151617 //stage 1 &#123; $group: &#123; _id: &apos;$id&apos;, visitCount: &#123;$last: &apos;$visitCount&apos;&#125;, topics: &#123;$last: &apos;$topics&apos;&#125;, answerCount: &#123;$last: &apos;$answerCount&apos;&#125;, created: &#123;$last: &apos;$created&apos;&#125;, updateTime: &#123;$last: &apos;$updateTime&apos;&#125;, commentCount: &#123;$last: &apos;commentCount&apos;&#125;, followerCount: &#123;$last: &apos;followerCount&apos;&#125; &#125; &#125;,//stage 2 &#123; $out: &quot;d_questions&quot; &#125;, 选中collections 然后找到aggressive选项 然后把上面这一块paste上去 。它的意思就相当于mysql中的distinct+group by ，再把结果输出在d_questions这个collections里面。 123456789&#123; $group: &#123; _id: &apos;$answerCount&apos;, count:&#123;&quot;$sum&quot;:1&#125; &#125; &#125;, &#123; $out: &quot;t&quot; &#125;, 同理 这一块的意思是 聚合分类 比如评论数为1的个数是5000条 评论数为60 的个数只有1 ，用于后面做词云图等等。这是爬知乎数据做可视化分析的 github地址：https://github.com/zhangjing9898/zhihu-data-view]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[antd pro]]></title>
    <url>%2F2018%2F01%2F25%2F2018-01-25-antd%20pro%2F</url>
    <content type="text"><![CDATA[在使用ant design pro 的时候遇到一个问题，webstorm一直报一个错误：ESLint: Expected linebreaks to be ‘CRLF’ but found ‘LF’;试过2个办法都不行，后来找到一个办法： 将.eslintrc文件下的”rules”:{ “linebreak-style”: 0,}]]></content>
      <categories>
        <category>ESlint</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css3瀑布流]]></title>
    <url>%2F2018%2F01%2F21%2F2018-01-21-css3%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
    <content type="text"><![CDATA[大一的时候用css3，原生js和jQuery3中写过瀑布流效果。现在开发一个摄影网站，里面会用到瀑布流效果，我选择使用css3，因为他的性能优于js。然后遇到一个问题，图片跟底部的文字有时候会发生分离。尝试了几种办法都不行。直到！！！/p&gt;我发现css3的一个新属性，非常好用！column-break-inside: avoid;这里的avoid:避免在元素内部断行并产生新列这样问题就得到了解决html代码: Title 1 Description 1 ….//moreless.gallery{ width: 1000px; column-width: 280px; -webkit-column-width: 280px; -moz-column-width: 280px; -webkit-column-gap: 10px; column-gap: 10px; margin: 0 auto; padding-top: 30px; margin-bottom: 20px; .white-panel{ display: block; background: #f9f9f9; border-bottom: 2px solid #c99a05; padding: 8px; padding-top: 20px; -webkit-column-break-inside: avoid; //很重要的一个属性 avoid:避免在元素内部断行并产生新列 -moz-column-break-inside: avoid; column-break-inside: avoid; img{ width: 100%; max-width: 100%; height: auto; } h1 { font-size: 1em; } a{ color: #8a6d3b; font-size: 18px; } &amp;:hover { cursor: pointer; border-bottom-color: #3c99b0; -webkit-transition: all 0.3s ease-in-out; -moz-transition: all 0.3s ease-in-out; -o-transition: all 0.3s ease-in-out; transition: all 0.3s ease-in-out; } }}最后，今天在安装sass的时候，一直出一个问题，推荐一篇博客http://blog.csdn.net/chris_ime/article/details/52013349]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DHC安装]]></title>
    <url>%2F2017%2F12%2F11%2F2017-12-11-DHC%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[DHC的安装 前端儿们在使用ajax的时候，总会遇到需要测试get或者post请求，get还好直接在浏览器上测试，post就比较麻烦了，这里推荐一款DHC插件，挺不错的，但是需要你科学上网，也就是fanqiang才能用。 所以这里给出3个教程，按步走下去，就可以安装成功，亲测有效 1.http://chromecj.com/web-development/2015-08/549.html 下载插件 2.http://chromecj.com/utilities/2014-09/181.html 3.第二步如果执行不成功，请参考这篇教程 http://chromecj.com/utilities/2015-04/423.html]]></content>
      <categories>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在cmd中kill 端口]]></title>
    <url>%2F2017%2F09%2F25%2F2017-09-25-cmd%E4%B8%ADkill%20%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[通过控制台杀死一个占用端口的进程 今天在写代码的时候，重开了2个3000端口，所以需要先kill掉再重开，网上的解决的方法很多，最简单有效的是重启电脑，我们也可以重启编译器，但是这个方法有时候会失效，可是重启电脑又很麻烦。这时就可以通过控制台来杀死占用端口的进程。 接下来使用一个特别简单的方法，记录一哈： 1.首先打开控制台,输入cmd 2.输入netstat -ano|findstr 3000(端口号) 3.taskkill /pid 1780(这个数字是上一行命令结束后，显示的一行中最后一组数字，每个端口不同，LISTENING 后面的那一组数字) 4.如果提示无法终止进程，就用/f强制杀死进程：输入taskkill /f /pid 1780]]></content>
      <categories>
        <category>cmd</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongoVUE]]></title>
    <url>%2F2017%2F09%2F23%2F2017-09-23-mongoVUE%2F</url>
    <content type="text"><![CDATA[mongoVUE 这里有一个坑，关于安装好mongoVUE之后，更新了collections，可vue中无法显示的问题,根据强大的网友，找出了破解的方法，在下面记录一番，防止自己忘记了。 今天安装MongoDB v3.2.8后，安装了它的一个可视化工具，MongoVUE，但是在操作数据库一切正常的情况下，在MongoVUE中无法查看到collections中的文件，但是在cmd中一切操作正常，也能用find()找到刚才插入的数据。百度了一下，换了很多关键词，找了很久没有找到对策，最后终于发现了一条，并且成功解决了这个问题。原因是mongodb3.2版本以后默认的开启的是wiredTiger存储引擎，而之前一直使用mmavp1存储，而且两种文件不兼容。 废话不多说，直接写具体操作: 1.首先将存放数据的文件夹清空，比如我放的就是c:\mongo,直接将里面的内容全部删除 2.在cmd中，进入mongodb所在的文件夹，例如我放的是c:\mongo，然后输入mongod –storageEngine mmapv1 –dbpath c:\mongo 注意输入的是引号中的内容，注意其中的空格，以及最后的是数据存储路径,这样就可以了]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[express 路由]]></title>
    <url>%2F2017%2F09%2F21%2F2017-09-20-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[路由 当用get请求访问一个网址的时候，做什么事情： 1app.get("网址",function(req,res){ 2 3}); 当用post请求访问一个网址的时候，做什么事情： 1app.post("网址",function(req,res){ 2 3}); 这里的网址，不分大小写，也就是说，你路由是 1app.get("/AAb",function(req,res){ 2 res.send("你好"); 3}); 实际上小写的访问也行。 所有的GET参数，? 后面的都已经被忽略。 锚点#也被忽略 你路由到/a ， 实际/a?id=2&sex=nan 也能被处理。 正则表达式可以被使用。正则表达式中，未知部分用圆括号分组，然后可以用req.params[0]、[1]得到。 req.params类数组对象。 1app.get(/^\/student\/([\d]{10})$/,function(req,res){ 2 res.send("学生信息，学号" + req.params[0]); 3}); 冒号是更推荐的写法。 1app.get("/student/:id",function(req,res){ 2 var id = req.params["id"]; 3 var reg= /^[\d]{6}$/; //正则验证 4 if(reg.test(id)){ 5 res.send(id); 6 }else{ 7 res.send("请检查格式"); 8 } 9}); 表单可以自己提交到自己上。下面这是一段伪代码 1app.get("/",function(req,res){ 2 res.render("form"); 3}); 4 5app.post("/",function(req,res){ 6 //将数据添加进入数据库 7 res.send("成功"); 8}); 总结： 适合进行 RESTful路由设计。简单说，就是一个路径，但是http method不同，对这个页面的使用也不同。 /student/345345 get 读取学生信息 add 添加学生信息 delete 删除学生新]]></content>
      <categories>
        <category>Node.js</category>
        <category>Express</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[express-中间件]]></title>
    <url>%2F2017%2F09%2F20%2F2017-09-20-%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[中间件 如果我的的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。 如果想往下匹配的话，那么需要写next() 1app.get("/",function(req,res,next){ 2 console.log("1"); 3 next(); 4}); 5 6app.get("/",function(req,res){ 7 console.log("2"); 8}); 下面两个路由，感觉没有关系：(但是实际上冲突了，因为admin可以当做用户名 login可以当做id。) 1app.get("/:username/:id",function(req,res){ 2 console.log("1"); 3 res.send("用户信息" + req.params.username); 4}); 5 6app.get("/admin/login",function(req,res){ 7 console.log("2"); 8 res.send("管理员登录"); 9}); 解决方法1：交换位置。 也就是说，express中所有的路由（中间件）的顺序至关重要。 匹配上第一个，就不会往下匹配了。 具体的往上写，抽象的往下写。 1app.get("/admin/login",function(req,res){ 2 console.log("2"); 3 res.send("管理员登录"); 4}); 5 6app.get("/:username/:id",function(req,res){ 7 console.log("1"); 8 res.send("用户信息" + req.params.username); 9}); 解决方法2： 1app.get("/:username/:id",function(req,res,next){ 2 var username = req.params.username; 3 //检索数据库，如果username不存在，那么next() 4 if(检索数据库){ 5 console.log("1"); 6 res.send("用户信息"); 7 }else{ 8 next(); 9 } 10}); 11 12app.get("/admin/login",function(req,res){ 13 console.log("2"); 14 res.send("管理员登录"); 15});]]></content>
      <categories>
        <category>Node.js</category>
        <category>Express</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[express框架]]></title>
    <url>%2F2017%2F09%2F19%2F2017-09-19-express%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Express框架 Express框架是后台的Node框架，所以和jQuery、zepto、yui、bootstrap都不一个东西。 Express在后台的受欢迎的程度，和jQuery一样，就是企业的事实上的标准。 ● 原生Node开发，会发现有很多问题。比如： ■ 呈递静态页面很不方便，需要处理每个HTTP请求，还要考虑304问题 ■ 路由处理代码不直观清晰，需要写很多正则表达式和字符串函数 ■ 不能集中精力写业务，要考虑很多其他的东西 EXPRESS的哲学是在你的想法和服务器之间充当薄薄的一层。这并不意味着他不够健壮，或者没有足够的有用特性,而是尽量少干预你，让你充分表达自己的思想，同时提供一些有用的东西。 英语官网： 中文官网： 安装Express框架，就是使用npm的命令 npm install --save express --save参数，表示自动修改package.json文件，自动添加依赖项。 路由功能: 1var express = require("express"); 2 3var app = express(); 4 5app.get("/",function(req,res){ 6 res.send("你好"); 7}); 8 9app.get("/haha",function(req,res){ 10 res.send("这是haha页面，哈哈哈哈哈哈"); 11}); 12 13app.get(/^\/student\/([\d]{10})$/,function(req,res){ 14 res.send("学生信息，学号" + req.params[0]); 15}); 16 17app.get("/teacher/:gonghao",function(req,res){ 18 res.send("老师信息，工号" + req.params.gonghao); 19}); 20 app.listen(3000); 静态文件能力： app.use(express.static("./public")); 模板引擎： 1var express = require("express"); 2 3var app = express(); 4 5app.set("view engine","ejs"); 6 7app.get("/",function(req,res){ 8 res.render("haha",{ 9 "news" : ["我是小新闻啊","我也是啊","哈哈哈哈"] 10 }); 11}); 12 app.listen(3000);]]></content>
      <categories>
        <category>Express</category>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(4)]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-node.js(4)%2F</url>
    <content type="text"><![CDATA[原生node.js中，如何处理这么一个问题，把异步变同步 这里会运用到迭代器这个小函数 话不多说，直接上代码： var http = require("http"); var fs = require("fs"); var server = http.createServer(function(req,res){ //不处理收藏夹小图标 if(req.url == "/favicon.ico"){ return; } //遍历album里面的所有文件、文件夹 fs.readdir("./album/",function(err,files){ //files : ["0.jpg","1.jpg" ……,"aaa","bbb"]; //files是一个存放文件(夹)名的数组 //存放文件夹的数组 var wenjianjia = []; //迭代器就是强行把异步的函数，变成同步的函数 //1做完了，再做2；2做完了，再做3 (function iterator(i){ //遍历结束 if(i == files.length){ console.log(wenjianjia); return; } fs.stat("./album/" + files[i],function(err,stats){ //检测成功之后做的事情 if(stats.isDirectory()){ //如果是文件夹，那么放入数组。不是，什么也不做。 wenjianjia.push(files[i]); } iterator(i+1); }); })(0); }); res.end(); }); server.listen(3000,"127.0.0.1");]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(2)]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-node.js(2)%2F</url>
    <content type="text"><![CDATA[#很重要的一点：node.js本质上是没有web容器 一、node.js本质上是没有web容器的，它可以把router做的非常漂亮，也非常具有隐蔽性和欺骗性 下面给出一段代码： 先给出目录结构： >demo1 >>test >>>0.jpg >>>aaaaaa.css >>>haha.html >>>xixi.html >>02_staticRender.js 代码： //require表示引包，引包就是引用自己的一个特殊功能 var http = require("http"); var fs = require("fs"); var path = require("path"); // import a from 'one.html' //创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么 var server = http.createServer(function(req,res){ console.log(req.url); if(req.url == "/fang"){ fs.readFile(path.join(__dirname,'./test/xixi.html'),(err,data)=>{ //req表示请求，request; res表示响应，response //设置HTTP头部，状态码是200，文件类型是html，字符集是utf8 res.writeHead(200,{"Content-type":"text/html;charset=UTF-8"}); res.end(data); }); }else if(req.url == "/yuan"){ fs.readFile(path.join(__dirname,"./test/haha.html"),function(err,data){ //req表示请求，request; res表示响应，response //设置HTTP头部，状态码是200，文件类型是html，字符集是utf8 res.writeHead(200,{"Content-type":"text/html;charset=UTF-8"}); res.end(data); }); }else if(req.url == "/0.jpg"){ fs.readFile(path.join(__dirname,"./test/0.jpg"),function(err,data){ //req表示请求，request; res表示响应，response //设置HTTP头部，状态码是200，文件类型是html，字符集是utf8 res.writeHead(200,{"Content-type":"image/jpg"}); res.end(data); }); }else if(req.url == "/bbbbbb.css"){ fs.readFile(path.join(__dirname,"./test/aaaaaa.css"),function(err,data){ //req表示请求，request; res表示响应，response //设置HTTP头部，状态码是200，文件类型是html，字符集是utf8 res.writeHead(200,{"Content-type":"text/css"}); res.end(data); }); }else{ res.writeHead(404,{"Content-type":"text/html;charset=UTF-8"}); res.end("没有这个页面呦"); } }); //运行服务器，监听3000端口（端口号可以任改） server.listen(3000,"127.0.0.1"); 最后，总结： node.js本质上是没有web容器 url通过了node的顶层路由设计，呈递某个静态文件 举一个经典的例子： 127.0.0.1:3000/yuan 这个页面有有一个图片 图片的源码是 那么你是不是会认为img是在127.0.0.1:3000/yuan/0.jpg 这个认为是错误的！ 中的yuan不是文件夹，所有都处于根目录，意思是img是127.0.0.1:3000/0.jpg]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(3)]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-node.js(3)%2F</url>
    <content type="text"><![CDATA[HTTP模块 node.js中，将很多的功能划分为一个个module，你想用什么就require什么。 http模块中比较重要的一点就是，要记得res.end()! var http=require("http"); //创建一个服务器，回调函数表示接收到请求之后做的事情 var server = http.createServer(function (req,res) { //req参数表示request，res=response console.log("服务器接收到了请求:"+req.url); //每一次都要res.end（）,不然loading会一直转 res.end("完毕") }); server.listen(3000,"127.0.0.1"); var http=require("http"); //创建一个服务器，回调函数表示接收到请求之后做的事情 var server = http.createServer(function (req,res) { //req参数表示request，res=response console.log("服务器接收到了请求:"+req.url); //每一次都要res.end（）,不然loading会一直转 res.writeHead(200,{"Content-Type":"text/html;charset=UTF8"}); res.write("1121"); //write和end中都必须是字符串 res.end("完毕") }); server.listen(3000,"127.0.0.1");]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(5)]]></title>
    <url>%2F2017%2F09%2F17%2F2017-09-17-node.js(5)%2F</url>
    <content type="text"><![CDATA[复习： Node.js开发服务器，数据、路由。本地关心的效果，交互； Node.js实际上是极客开发出的一个小玩具，不是银弹。有着别人不具备的怪异特点： 单线程、Non-blocking I/O、Event Driven。 实际上是一个特点。 首先，Node不为每个用户开辟一个线程，所以非常极端的选择了单线程。 单线程，要照顾所有的用户，那么就必须有非阻塞I/O，否则一个人的I/O就把别人、自己都阻塞了。 一旦有非阻塞I/O，一个人如果I/O去了，就会放弃CPU的使用权，换成另一个人使用CPU（或者执行此人后面的语句）。 所以CPU的利用率100%。第一个人I/O结束了，就要用事件来通知线程，执行回调函数。 此时必须有事件环，就有一个排队调度机制。Node中有超过半数的C++代码，在搭建事件环。 Node.js和别的老牌3P不一样： 1)没有自己的语法，使用V8引擎，所以就是JS。 V8引擎解析JS的，效率非常高，并且V8中很多东西都是异步的。 Node就是将V8中的一些功能自己没有重写（别人做了，自己就站在巨人肩膀上），移植到了服务器上。 2)没有web容器，就是安装配置完成之后，没有一个根目录。 命令提示符所在路径太重要了，因为程序中的所有相对路径”./”，都是相对这个命令提示符路径的，而不是相对于js文件自己。 系统中，80端口，就是默认http端口。所以当没有端口号的时候，就是80端口。 server.listen(80,"127.0.0.1"); 二、模块 ● 在Node.js中，以模块为单位划分所有功能， 并且提供了一个完整的模块加载机制， 这时的我们可以将应用程序划分为各个不同的部分。 不可能用一个js文件去写全部的业务。肯定要有MVC。 ● 狭义的说，每一个JavaScript文件都是一个模块； 而多个JavaScript文件之间可以相互require，他们共同实现了一个功能， 他们整体对外，又称为一个广义上的模块。 ● Node.js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。 当需要从此JS文件外部引用这些变量、函数时，必须使用exports对象进行暴露。 使用者要用require()命令引用这个JS文件。 foo.js文件中的代码： 1var msg = "你好"; 2 3exports.msg = msg; msg这个变量，是一个js文件内部才有作用域的变量。 如果别人想用这个变量，那么就要用exports进行暴露。 使用者： 1var foo = require("./test/foo.js"); 2 3console.log(foo.msg); 使用者用foo来接收exports对象，也就是说，这里的foo变量，就是文件中的exports变量。 ● 一个JavaScript文件，可以向外exports无数个变量、函数。 但是require的时候，仅仅需要require这个JS文件一次。 使用的它的变量、函数的时候，用点语法即可。 所以，无形之中，增加了一个顶层命名空间。 js文件中，可以用exports暴露很多东西，比如函数、变量。 1var msg = "你好"; 2var info = "呵呵"; 3 4function showInfo(){ 5 console.log(info); 6} 7 8exports.msg = msg; 9exports.info = info; 10exports.showInfo = showInfo; 在使用者中，只需要require一次。 1var foo = require("./test/foo.js"); 相当于增加了顶层变量。所有的函数、变量都要从这个顶层变量走： 1console.log(foo.msg); 2console.log(foo.info); 3foo.showInfo(); Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。 不是靠html文件统一在一起的。 ● 可以将一个JavaScript文件中，描述一个类。用 module.export = 构造函数名; 的方式向外暴露一个类。 也就是说，js文件和js文件之间有两种合作的模式： 1） 某一个js文件中，提供了函数，供别人使用。 只需要暴露函数就行了； exports.msg=msg; 2） 某一个js文件，描述了一个类。 module.exports = People; ● 如果在require命令中，这么写: 1var foo = require("foo.js"); //没有写./， 所以不是一个相对路径。是一个特殊的路径 那么Node.js将该文件视为node_modules目录下的一个文件 ● node_modules文件夹并不一定在同级目录里面，在任何直接祖先级目录中，都可以。甚至可以放到NODE_PATH环境变量的文件夹中。 分享项目的时候，不需要带着modules一起给别人。 ● 我们可以使用文件夹来管理模块，比如 1var bar = require("bar"); 那么Node.js将会去寻找node_modules目录下的bar文件夹中的index.js去执行。 每一个模块文件夹中，推荐都写一个package.json文件，这个文件的名字不能改。 node将自动读取里面的配置。有一个main项，就是入口文件： 1{ 2 "name": "kaoladebar", 3 "version": "1.0.1", 4 "main" : "app.js" 5} 6 package.json文件，要放到模块文件夹的根目录去。 我们刚才学习了，模块就是一些功能的封装，所以一些成熟的、经常使用的功能，都有人封装成为了模块。 并且放到了社区中，供人免费下载。 这个伟大的社区，叫做npm。 也是一个工具名字 node package management https://www.npmjs.com/ 去社区搜索需求，然后点进去，看api。 如果要配置一个模块，那么直接在cmd使用 1npm install 模块名字 就可以安装。 模块名字全球唯一。 安装的时候，要注意，命令提示符的所在位置。 1.我们的依赖包，可能在随时更新，我们永远想保持更新，或者某持某一个版本； 2.项目越来越大的时候，给别人看的时候，没有必要再次共享我们引用的第三方模块。 我们可以用package.json来管理依赖。 在cmd中，使用npm init可以初始化一个package.json文件，用回答问题的方式生成一个新的package.json文件。 使用 npm install 将能安装所有依赖。 npm也有文档，这是package.json的介绍： https://docs.npmjs.com/files/package.json require()别的js文件的时候，将执行那个js文件。 注意： require()中的路径，是从当前这个js文件出发，找到别人。而fs是从命令提示符找到别人。 所以，桌面上有一个a.js， test文件夹中有b.js、c.js、1.txt a要引用b： var b = require(“./test/b.js”); b要引用c： var b = require(“./c.js”); 但是，fs等其他的模块用到路径的时候，都是相对于cmd命令光标所在位置。 所以，在b.js中想读1.txt文件，推荐用绝对路径： 1fs.readFile(__dirname + "/1.txt",function(err,data){ 2 if(err) { throw err; } 3 console.log(data.toString()); 4});]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(1)]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-node.js(1)%2F</url>
    <content type="text"><![CDATA[一、Node.js的三大特点： 1.单线程 优点： 让node.js宏观上并发。 操作系统不再有线程创建、销毁的时间开销。 坏： 一个用户崩溃，整个服务器所有用户崩溃。 2.非阻塞I/O 相当于异步 线程cpu核心利用率永远是100% 3.事件驱动 事件机制、事件环 其实3个特点就是一个特点，少一个环节都没有办法运行 二、Node.js适合开发的业务： 简单来说： node.js: 善于I/O 不善于计算； 三、helloWorld代码 var http = require("http"); var server = http.createServer(function (req,res) { res.writeHead(200,{ "Content-type":"text/html;charset=UTF-8" }); res.end("我买了5个iphone"+(1+2+3)+"s"); }); //运行服务器,监听3000端口，端口号可更改 server.listen(3000,"127.0.0.1"); 四、如何在cmd中运行文件： node + “文件名” such as：C：\Users\ZJ>node d:\workspaces\node.js\demo1\01_helloWorld.js 五、总结 node.js是服务器的程序，写的js脚本是运行在服务器上！返回给客户的，只是纯html语句（重点提醒） ！！！node.js 可以直接运行js文件，不需要html模块的封装 node相当于js的执行环境 总结来说： 我们现在要跑起一个服务器，这个服务器的脚本，要以.js存储，是一个js文件，用node命令运行这个js文件罢了。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2017%2F09%2F09%2F2017-09-09-ES6%2F</url>
    <content type="text"><![CDATA[ES6 知识点总结 主要有19个小节，会贴出相对应的demo代码，也会在最后给出对应GitHub地址 1.let const12345678910111213141516171819202122232425/**let，const 块作用域内有效 &#123;&#125;内代表一块*//**ES6 use strict*/function test() &#123; // for(let i=1;i&lt;3;i++)&#123; // console.log(i); // &#125; // console.log(i); /**let 申明变量是不能重复定义*/ // let a= 1; // let a=2;&#125;function last() &#123; /*const常量不能修改(数值) 对象可以，如const k=&#123;&#125; * 申明时必须赋值 * */ const PI=3.1415926; const k=&#123; a:1 &#125; k.b=3; console.log(PI,k);&#125;last(); 2.解构赋值主要讲解了数组解构赋值和对象解构赋值,其他的都可以在上面拓展依然贴上代码: 3.正则拓展新增了2个修饰符 y和u，下面给出代码： 4.字符串拓展（上）Unicode编码的一些问题，贴上代码，应该去敲一遍就可以理解这里提醒，需要npm install babel-polyfill；得安装这么个补丁包才行 5.字符串拓展（下）主要讲解了一些日常中实用方便的方法,老规矩贴上代码: 6.数值拓展跟数值有关的一些小方法，仅仅码出了常用的小部分，更多请查阅 7.数组拓展 8.函数拓展箭头函数，尾调用… 9.对象拓展 10.Symbol的用法 11.set map数据结构简单介绍了Set WeakSet Map WeakMap 12.map-set与数组和对象的比较将map set与数组和object都进行了增删改查的比较 13.Proxy和Reflect 14.类与对象 15.promise主要讲解了promise的原理，以及promise.all和promise.race的用法 16.Iterator 和 for of 17 GeneratorGenerator基本定义，以及2个工作学习中常用到2个方法，长轮询和类似抽奖的一个次数记录 18.Decorators修饰器 19.模块化export:(2种方法，个人比较喜欢最后一种) 123456789101112131415161718192021222324252627282930313233343536373839//模块引用 import//模块导出 export// export let A=123;//// export function test() &#123;// console.log('test');// &#125;//// export class Hello&#123;// test()&#123;// console.log('class');// &#125;// &#125;export let A=123;export function test() &#123; console.log('test');&#125;export class Hello&#123; test()&#123; console.log('class'); &#125;&#125;export default&#123; A,test,Hello&#125;// import &#123;A,test,Hello&#125; from './class/lesson17';// import * as lesson17 from './class/lesson17';//// console.log(lesson17.A);import Lesson17 from './class/lesson17';console.log(Lesson17.A); 在学习完ES6的基本语法后，我也去做了一个购买彩票的一个小网址，基于es6+gulp+webpack，后台用的mockjs的模拟数据我把es6知识点的代码跟彩票项目代码放在一起的，这个给出地址:https://github.com/zhangjing9898/Lottery]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http-web综合问题]]></title>
    <url>%2F2017%2F09%2F08%2F2018-04-26-http-web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[HTTP web 综合问题1.Html5 语义化理解 用正确的标签做正确的事 html 语义化就是让页面的内容结构化，便于浏览器、搜索引擎解析 在没有样式 CSS 情况下也可以以一种文档格式显示，可读性强 让阅读源代码的人 更容易将网站分块 便于阅读维护理解 2.HTML5 为什么只需要写&lt;!DOCTYPE HTML&gt;？ html5 不需要对 DTD（document type definition）进行引用，但是需要 doctype 来规范浏览器行为 CSS 部分css 优先级 载入样式以最后载入的定位为准 优先级为:!important&gt;行内&gt;id&gt;class&gt;tag&gt;通配符&gt;继承&gt;默认 https://blog.csdn.net/qq_28300493/article/details/52297165 说说你对 AMD 和 Commonjs 的理解 CommonJS 是服务器端模块的规范，Node.js采用了这个规范。CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数 AMD 推荐的风格通过返回一个对象做为模块对象，CommonJS 的风格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的目的 用过哪些设计模式？ 工厂模式 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是 new 关键字 工厂模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是 Object 类型这是一个代码实例，更加形象: 1234567891011121314151617181920212223242526272829&lt;script type="text/javascript"&gt; function createPerson(name, age) &#123; //返回一个对象的函数===&gt;工厂函数 var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj &#125; // 创建2个人 var p1 = createPerson('Tom', 12) var p2 = createPerson('Bob', 13) // p1/p2是Object类型 function createStudent(name, price) &#123; var obj = &#123; name: name, price: price &#125; return obj &#125; var s = createStudent('张三', 12000) // s也是Object&lt;/script&gt; 构造函数模式 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 直接将属性和方法赋值给 this 对象; 自定义构造函数模式 套路: 自定义构造函数, 通过 new 创建对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 123456789101112131415161718192021222324&lt;script type=&quot;text/javascript&quot;&gt; //定义类型 function Person(name, age) &#123; this.name = name this.age = age this.setName = function(name) &#123; this.name = name &#125; &#125; var p1 = new Person(&apos;Tom&apos;, 12) p1.setName(&apos;Jack&apos;) console.log(p1.name, p1.age) console.log(p1 instanceof Person) function Student(name, price) &#123; this.name = name this.price = price &#125; var s = new Student(&apos;Bob&apos;, 13000) console.log(s instanceof Student) var p2 = new Person(&apos;JACK&apos;, 23) console.log(p1, p2)&lt;/script&gt; length 的巧妙用法123456789 var arr1=arr2=[1,2,3];//清空数组arr1.length=0;console.log(arr1,arr2);//output &apos;&apos; &apos;&apos;//截断arrayarr1.length=1;console.log(arr1,arr2);//output [1] 合并数组的巧妙方法123456789101112//普通方法 concatarr1=[1,2,3][1, 2, 3]arr2=[4,5,6][4, 5, 6]arr1.concat(arr2)[1, 2, 3, 4, 5, 6]//用pushlet arr1 = [1, 2, 3, 4, 5];let arr2 = [6, 7, 8, 9, 10];Array.prototype.push.apply(arr1, arr2); 判断是否为数组//在 es5 中isArray 方法 Boolean//其他方法array.prototype.toString==”object array”]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[放弃一个喜欢了很久的人，是一种什么感受？]]></title>
    <url>%2F2016%2F12%2F26%2F%E6%94%BE%E5%BC%83%E4%B8%80%E4%B8%AA%E5%96%9C%E6%AC%A2%E5%BE%88%E4%B9%85%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[前段时间，在微博上看到了一个挺有趣的提问，它说“放弃一个自己喜欢了很久的人，是一种什么感受？”我随即在下面评论了一句：“感觉身体被掏空了”，本来这是一挺让人伤感的话题，我却逼逼了这么傻逼的一句。 其实我当时评论的第一反应是：“那我可能再也遇不到一个这么喜欢的人了”。 后来，听一个朋友讲了她的一些事情后，我对这个提问，有了个新的答案。 这个朋友就称她为小A吧，暂时想不出更好的名字代号。在这里梳理一下故事发生的背景，小A有一个玩的挺好的朋友，那么我就称他为小B吧，小A和小B是很要好的中学同学，要好的程度就是那种，随时都在一块，形影不离，而且俩人特多的共同点，很多习性都惊人的一致，但是俩人确实都只把对方当做好朋友那种。 后来上大学了，小A和小B上了不同的大学，各自也有了各自的朋友圈，见面的时间少了很多，但小A和小B在网上也有经常联系什么鬼的。 小A告诉我，她整整高中三年都没有喜欢过小B，直到后来上了大学，身边没有了他。 小A每次都是断断续续的讲一些她的事情，她说，她也不知道为什么后来对小B的感情就变了。我说，但是感情这事不本来就是说不清楚的吗，更何况物是人非事事休，别人会变，你会变，感情也会变啊。 就在前几天，小A突然给我发了一个截图，那个截图上面是她的之前写的一篇日记。 她的日记是这样写的: 你背对着山河一步步走向我，你脚踏着山河一步步走近我。 每次听《祝星》都会带给我不一样的感动。 我给你写过好多好多话，写了好多好多段子，写了好多好多文章，但是它们最终都只能存在我的手机里，不见天日。 我写:你有时看群山，有时看绿水，有时看落日，有时看人群，却独独不看我。 我写:在所有物是人非的景色里，我最喜欢你。 我写:我来人间一趟，我要看看太阳，和我的心上人，一起走在街上。 我写:我只能活一次，我要去活成我想要的样子。 我写:我知道我们只能是好朋友，每次我在说服自己放弃吧的时候，总会有个小侥幸跳出来，它说:再等等吧。 我问自己，喜欢一个人是什么样的？ 喜欢一个人，就是手心中明明只有两颗糖，却想给他五颗糖。看见一部喜欢的电影，想要分享给他，吃到自己喜欢的东西，便想着给他也带一份，看到一片美丽的风景，便会想着下次要带他过来一起看，甚至偶然听到一个段子，都想着讲给他听的时候，他会不会笑。 经常看见有人说，真正的喜欢是，他想要香蕉就给他香蕉，而不是拼命给他塞苹果，可是，身在其中的人，只想把自己最喜欢的东西给对方，想把自己觉得好的东西都塞给他，不管他想不想要。 到如今，我不是喜欢你，也不是不喜欢你，我对你想不出一句该说的话，不想看你，也不能看你，不想你走来，更不想你走开。 我对你有些穷尽一生不可磨灭的柔情，却不知该如何给你，你是我卡在喉咙里仍未取的刺。 我也不知道这篇日记会在我手机里存多久，应该不会多久了，因为热情终将会过去，而一切都会正常起来，只要生命的车轮还能转动，那我终有一天会走上正轨。 小A她说，她每次都会告诉自己再等等吧，可是等着等着，再热的情也会等冷，或者说，等着等着，就发现何必再用糖纸去包裹一粒沙子？认命得越早越幸福。她说，我现在才知道放下、放弃原来是悄无声息的。 今天，突然想起这个事情，想起这个问题，所以也没有经过她的同意，就把这个故事写出来，也不知道这样对不对。 爱能让人是非不分，这可能就是它最可贵的地方。 可是 感情一旦变味儿了，不如被时光的洪流裹挟而去，抱在怀里，也酿不成酒，也醉不了人。 每个人都有选择去喜欢或者放弃的权利，但是一旦选择了你就应该去承担它所带来的一切，如《陆垚知马俐》里有句台词：爱能让你骄傲如烈日，也能让你卑微入尘土。 所以，现在的我，当我再次听到“放弃一个喜欢了很久的人，是一种什么感受？”的时候，有了一个新的答案： 感情没有对错，错的是时间。 放弃也未必不是好事。 今天是2017.11.11]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
